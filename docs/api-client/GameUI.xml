<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GameUI</name>
    </assembly>
    <members>
        <member name="T:GameUI.Brush.ColorBrush">
            <summary>
            表示颜色画刷的基类。
            </summary>
        </member>
        <member name="M:GameUI.Brush.ColorBrush.ToRgbaHex">
            <summary>
            转换为 RGBA 十六进制字符串。
            </summary>
            <returns>RGBA 格式的颜色字符串。</returns>
        </member>
        <member name="T:GameUI.Brush.SolidColorBrush">
            <summary>
            表示单色画刷。
            </summary>
        </member>
        <member name="M:GameUI.Brush.SolidColorBrush.#ctor(System.Drawing.Color)">
            <summary>
            表示单色画刷。
            </summary>
        </member>
        <member name="P:GameUI.Brush.SolidColorBrush.Color">
            <summary>
            获取或设置画刷的颜色。
            </summary>
        </member>
        <member name="M:GameUI.Brush.SolidColorBrush.op_Implicit(System.Drawing.Color)~GameUI.Brush.SolidColorBrush">
            <summary>
            隐式转换 Color 为 SolidColorBrush。
            </summary>
            <param name = "color">颜色值。</param>
        </member>
        <member name="M:GameUI.Brush.SolidColorBrush.op_Implicit(GameUI.Brush.SolidColorBrush)~System.Drawing.Color">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Brush.SolidColorBrush.ToRgbaHex">
            <inheritdoc/>
        </member>
        <member name="M:GameUI.Brush.SolidColorBrush.ToString">
            <inheritdoc/>
        </member>
        <member name="T:GameUI.Brush.GradientBrush">
            <summary>
            表示渐变色画刷。
            </summary>
        </member>
        <member name="P:GameUI.Brush.GradientBrush.TopLeft">
            <summary>
            获取或设置左上角颜色。
            </summary>
        </member>
        <member name="P:GameUI.Brush.GradientBrush.TopRight">
            <summary>
            获取或设置右上角颜色。
            </summary>
        </member>
        <member name="P:GameUI.Brush.GradientBrush.BottomLeft">
            <summary>
            获取或设置左下角颜色。
            </summary>
        </member>
        <member name="P:GameUI.Brush.GradientBrush.BottomRight">
            <summary>
            获取或设置右下角颜色。
            </summary>
        </member>
        <member name="M:GameUI.Brush.GradientBrush.ToRgbaHex">
            <inheritdoc/>
        </member>
        <member name="T:GameUI.Control.Control">
            <summary>
            
            </summary>
            <summary>
            Represents a base class for UI controls in the game UI system. Provides core logic for managing control hierarchy, data context, and interaction with the underlying game data.
            </summary>
            <remarks>
            This class implements <see cref = "T:GameData.Interface.IGameObject`1"/> and <see cref = "T:GameUI.Interface.INodeChild"/> interfaces, enabling integration with the game data layer and UI tree structure.
            </remarks>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.CapturePointer(GameCore.Platform.SDL.PointerButtons)">
            <summary>
            捕获指针输入。会使得控件接收到被捕获指针的移动事件(<see cref = "E:GameUI.Control.Control.OnPointerCapturedMove"/>), 直到释放捕获或抬起指针。
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.ReleasePointer(GameCore.Platform.SDL.PointerButtons)">
            <summary>
            释放捕获的指针输入。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.DefaultFontSize">
            <summary>
            The default font size for controls.
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.GameData#Interface#IGameObject#Link">
            <inheritdoc/>
        </member>
        <member name="P:GameUI.Control.Control.GameData#Interface#IGameObject#Cache">
            <inheritdoc/>
        </member>
        <member name="P:GameUI.Control.Control.Link">
            <summary>
            Gets the link to the game data control.
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Cache">
            <summary>
            Gets the cached game data control.
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.children">
            <summary>
            The list of child controls.
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Children">
            <summary>
            Gets or initializes the read-only list of child controls.
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Parent">
            <summary>
            Gets the parent node of this control.
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.GameUI#Interface#INode#Children">
            <inheritdoc/>
        </member>
        <member name="F:GameUI.Control.Control.dataContext">
            <summary>
            Gets or sets the data context for this control.
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.parent">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.DataContext">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControl},ClientCaller.SCEImportGUI.ControlType)">
            <summary>
            Initializes a new instance of the <see cref = "T:GameUI.Control.Control"/> class with the specified game data link and control type.
            This constructor creates a control based on the provided game data link and control type, applying any template data associated with the link. It also handles the creation of child controls defined in the game data link.
            </summary>
            <remarks>
            This constructor is typically used when creating controls that are defined in the game data, allowing for dynamic UI generation based on the game's configuration.
            </remarks>
            <param name = "link">The template data link for this control.</param>
            <param name = "type">The type of control to create.</param>
        </member>
        <member name="M:GameUI.Control.Control.ApplyTemplate(GameData.IGameLink{GameUI.Control.Data.GameDataControl})">
            <summary>
            Applies a template to this control using a game data link. Unlike the constructor, this method 
            allows for applying templates after the control has been created, but it will not create child 
            controls.
            </summary>
            <param name = "template">The template to apply.</param>
        </member>
        <member name="M:GameUI.Control.Control.ApplyTemplate(GameUI.Control.Data.GameDataControl)">
            <summary>
            Applies a template to this control using a game data control instance. This method allows for 
            applying templates after the control has been created, but it will not create child controls.
            This is useful for updating the control's properties without recreating it.
            </summary>
            <param name = "template">The template to apply.</param>
        </member>
        <member name="M:GameUI.Control.Control.AddChild(GameUI.Control.Control)">
            <summary>
            Adds a child control to this control.
            </summary>
            <param name = "child">The child control to add.</param>
            <returns>True if the child was added successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.AddToVisualTree">
            <summary>
            Adds this control to the visual tree root, making it and its children visible in the UI.
            </summary>
            <returns>True if added successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.AddToParent(GameUI.Interface.INode)">
            <summary>
            Adds this control to the specified parent node.
            </summary>
            <param name = "parent">The parent node.</param>
            <returns>True if added successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.AddToParent(GameUI.Interface.INode,System.Int32)">
            <summary>
            Adds this control to the specified parent node at the given index.
            </summary>
            <param name = "parent">The parent node.</param>
            <param name = "index">The index at which to insert the control.</param>
            <returns>True if added successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.RemoveChild(GameUI.Interface.INodeChild)">
            <summary>
            Removes the specified child from this control.
            </summary>
            <param name = "child">The child to remove.</param>
            <returns>True if removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.RemoveChild(System.Int32)">
            <summary>
            Removes the child at the specified index from this control.
            </summary>
            <param name = "index">The index of the child to remove.</param>
            <returns>True if removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.RemoveFromParent">
            <summary>
            Removes this control from its parent.
            </summary>
            <returns>True if removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:GameUI.Control.Control.FindChild(System.Func{GameUI.Control.Control,System.Boolean})">
            <summary>
            Finds the first child control that matches the specified condition.
            </summary>
            <param name = "condition">The condition to match.</param>
            <returns>The first matching child control, or null if none found.</returns>
        </member>
        <member name="M:GameUI.Control.Control.FindChild(System.String)">
            <summary>
            Finds the first child control with the specified name.
            </summary>
            <param name = "name">The name of the child control.</param>
            <returns>The first matching child control, or null if none found.</returns>
        </member>
        <member name="M:GameUI.Control.Control.FindChildren(System.String)">
            <summary>
            Finds all child controls with the specified name.
            </summary>
            <param name = "name">The name of the child controls.</param>
            <returns>An enumerable of matching child controls, or null if none found.</returns>
        </member>
        <member name="F:GameUI.Control.Control.controls">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.GetById(System.Int64)">
            <summary>
            根据控件 Id 获取 Control 实例。
            </summary>
            <param name = "id">控件的唯一标识符。</param>
            <returns>对应的 Control 实例，如果不存在则为 null。</returns>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerClicked">
            <summary>
            当控件被点击时触发。
            </summary>
            <remarks>
            点击的精确定义为：在当前控件上按下指针，然后在当前控件上释放指针。
            这个事件与和<see cref = "E:GameUI.Control.Control.OnPointerReleased"/>不同，尽管两者都在指针释放时触发，
            点击事件要求指针在同一个控件上按下和释放。而<see cref = "E:GameUI.Control.Control.OnPointerReleased"/>则是只要求当前控件上按下，
            在任何地方释放都会触发。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerClickedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerDoubleClicked">
            <summary>
            当控件被双击时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerDoubleClickedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerEntered">
            <summary>
            当指针进入控件区域时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerEnteredHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerExited">
            <summary>
            当指针离开控件区域时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerExitedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerPressed">
            <summary>
            当指针在控件上按下时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerPressedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerReleased">
            <summary>
            当控件上的指针释放时触发。
            </summary>
            <remarks>
            这个事件与<see cref = "E:GameUI.Control.Control.OnPointerClicked"/>不同，尽管两者都在指针释放时触发，
            点击事件要求指针在同一个控件上按下和释放。而<see cref = "E:GameUI.Control.Control.OnPointerReleased"/>则是只要求当前控件上按下，
            在任何地方释放都会触发。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerReleasedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnPointerCapturedMove">
            <summary>
            Occurs when a pointer moves while captured, it does not matter if the control has <see cref = "P:GameUI.Control.Control.AllowDrag"/>
            set to true or false.
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnPointerCapturedMoveHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnDrag">
            <summary>
            当控件被拖动时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnDragHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnDrop">
            <summary>
            当控件发生拖放操作时触发。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnDropHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnSizeChanged">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.OnSizeChangedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Control.OnChildPostInitialization">
            <summary>
            Occurs after a child control has been initialized, allowing for additional customization or setup.
            </summary>
            <remarks>This event is raised after the control initialization process is complete.  Subscribers can
            use this event to perform post-initialization tasks, such as  applying additional configurations or modifying
            the control.</remarks>
        </member>
        <member name="E:GameUI.Control.Control.OnKeyboardAcceleratorInvoked">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.EnsureValid">
            <summary>
            确保控件处于有效状态（未被摧毁），否则抛出异常。
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.DisposeManaged">
            <summary>
            释放托管资源，包括移除父子关系、销毁子控件、注销事件等。
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.DisposeUnmanaged(System.Boolean)">
            <summary>
            释放非托管资源，销毁底层控件句柄。
            </summary>
            <param name = "finalizing">指示是否为终结器调用。</param>
        </member>
        <member name="P:GameUI.Control.Control.ItemIndex">
            <summary>
            当前项在 ItemsSource 中的索引，未设置时为 -1。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ItemsSource">
            <summary>
            控件的数据源集合。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ItemTemplate">
            <summary>
            控件的项模板。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ItemTemplateSelector">
            <summary>
            控件的项模板选择器。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.generatedChildren">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.GeneratedChildren">
            <summary>
            获取由数据源自动生成的子控件集合（只读）。
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.GenerateChild(System.Object,GameUI.Control.Data.GameDataControl,System.Boolean)">
            <summary>
            根据数据项和模板生成子控件。
            </summary>
            <param name = "item">数据项。</param>
            <param name = "template">模板。</param>
            <param name = "addToParent">是否自动添加到父控件。</param>
            <returns>生成的子控件。</returns>
        </member>
        <member name="M:GameUI.Control.Control.GenerateChild(System.Object,GameUI.Control.Struct.ItemTemplateSelector,System.Boolean)">
            <summary>
            根据数据项和模板选择器生成子控件。
            </summary>
            <param name = "item">数据项。</param>
            <param name = "templateSelector">模板选择器。</param>
            <param name = "addToParent">是否自动添加到父控件。</param>
            <returns>生成的子控件。</returns>
        </member>
        <member name="M:GameUI.Control.Control.Template(System.Object)">
            <summary>
            根据数据项获取模板。
            </summary>
            <param name = "item">数据项。</param>
            <returns>对应的数据模板。</returns>
        </member>
        <member name="M:GameUI.Control.Control.GenerateChild(System.Object,System.Boolean)">
            <summary>
            根据数据项自动选择模板并生成子控件。
            </summary>
            <param name = "item">数据项。</param>
            <param name = "addToParent">是否自动添加到父控件。</param>
            <returns>生成的子控件。</returns>
        </member>
        <member name="M:GameUI.Control.Control.GenerateChildren">
            <summary>
            根据 ItemsSource 生成所有子控件。
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.GetChildByItem(System.Int32)">
            <summary>
            根据数据项索引获取对应的子控件。
            </summary>
            <param name = "itemIndex">数据项索引。</param>
            <returns>对应的子控件，如果不存在则为 null。</returns>
        </member>
        <member name="F:GameUI.Control.Control.keyboardAccelerators">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.KeyboardAccelerators">
            <summary>
            Gets or sets the collection of keyboard accelerators associated with this control.
            </summary>
            <remarks>
            Keyboard accelerators are keys (such as A) or key combinations (such as Ctrl+S or Alt+Enter) that allow users to quickly invoke specific actions on the control.
            When a registered accelerator is triggered and the control is functional, the corresponding action or event handler is executed.
            Controls like <see cref = "T:GameUI.Control.Primitive.Button"/> may have default actions (such as click) that are invoked by accelerators.
            Modifying this collection will automatically register or unregister the control for accelerator handling.
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.IsKeyboardAcceleratorsRegistered">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.RegisteredKeyboardAccelerators">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Control.OnKeyboardAcceleratorInvokedInternal(GameUI.Control.Struct.KeyboardAccelerator)">
            <summary>
            
            </summary>
            <param name="accelerator"></param>
            <returns></returns>
        </member>
        <member name="P:GameUI.Control.Control.ActualSizeDP">
            <summary>
            获取控件在设备像素（Device Pixel, DP）下的实际尺寸。只读属性。
            </summary>
            <remarks>
            The size is calculated dynamically and reflects the current dimensions of the element. Ensure
            that the element is in a valid state before accessing this property.
            通常控件在创建并添加到布局后，会等到该帧末才能获取到实际尺寸。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Control.ActualSize">
            <summary>
            获取控件在设备无关像素（DIP）下的实际尺寸。只读属性。
            </summary>
            <remarks>
            This property retrieves the current size of the element by ensuring its state is valid and
            querying the underlying system.
            通常控件在创建并添加到布局后，会等到该帧末才能获取到实际尺寸。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Control.ScreenPositionDP">
            <summary>
            获取控件在屏幕上的像素坐标（设备像素，Device Pixel, DP）。只读属性。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ScreenPosition">
            <summary>
            获取控件在屏幕上的坐标（设备无关像素，DIP）。只读属性。
            </summary>
            <remarks>The returned position is calculated based on the primary viewport's device pixel ratio to
            ensure consistency across devices with varying display densities.</remarks>
        </member>
        <member name="F:GameUI.Control.Control.position">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Position">
            <summary>
            控件的布局位置。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.positionType">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.PositionType">
            <summary>
            控件的布局定位类型，决定 <see cref = "P:GameUI.Control.Control.Position"/> 属性的含义。
            </summary>
            <remarks>
            <list type="bullet">
            <item><see cref = "F:GameUI.Enum.UIPositionType.Relative"/>：控件位置基于自身排版后的位置进行偏移。</item>
            <item><see cref = "F:GameUI.Enum.UIPositionType.Absolute"/>：控件位置基于父容器的左上角进行偏移。</item>
            </list>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.margin">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Margin">
            <summary>
            控件的外边距。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.padding">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Padding">
            <summary>
            控件的内边距。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.width">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Width">
            <summary>
            控件的宽度（支持 Auto）。设为 Auto 时，控件宽度将根据内容和其它属性自动调整。
            当前属性仅仅反映用户设置的宽度值。在尝试获取控件实际宽度尺寸时，应当使用 <see cref = "P:GameUI.Control.Control.ActualSize"/> 属性。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.height">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Height">
            <summary>
            控件的高度（支持 Auto）。设为 Auto 时，控件高度将根据内容和其它属性自动调整。
            当前属性仅仅反映用户设置的高度值。在尝试获取控件实际高度尺寸时，应当使用 <see cref = "P:GameUI.Control.Control.ActualSize"/> 属性。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.widthStretchRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.WidthStretchRatio">
            <summary>
            控件在父容器中的宽度拉伸比例。当父控件拥有足够空间时，控件将根据此比例扩展其宽度。0.5代表占用父容器剩余宽度的50%，1.0代表占用100%。
            控件的宽度拉伸比例决定了在父容器空间充足时，控件将如何扩展其宽度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.heightStretchRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.HeightStretchRatio">
            <summary>
            控件在父容器中的高度拉伸比例。当父控件拥有足够空间时，控件将根据此比例扩展其高度。0.5代表占用父容器剩余高度的50%，1.0代表占用100%。
            控件的高度拉伸比例决定了在父容器空间充足时，控件将如何扩展其高度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.widthCompactRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.WidthCompactRatio">
            <summary>
            控件在父容器中的宽度收缩比例。当父控件空间不足时，控件将根据此比例收缩其宽度。0.5代表占用父容器剩余宽度的50%，1.0代表占用100%。
            控件的宽度收缩比例决定了在父容器空间不足时，控件将如何收缩其宽度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.heightCompactRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.HeightCompactRatio">
            <summary>
            控件在父容器中的高度收缩比例。当父控件空间不足时，控件将根据此比例收缩其高度。0.5代表占用父容器剩余高度的50%，
            1.0代表占用100%。
            控件的高度收缩比例决定了在父容器空间不足时，控件将如何收缩其高度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.flowOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.FlowOrientation">
            <summary>
            控件的流式布局方向。<see cref = "F:GameUI.Enum.Orientation.Horizontal"/>代表水平布局，
            <see cref = "F:GameUI.Enum.Orientation.Vertical"/>代表垂直布局，
            <see cref = "!:Orientation.None"/>代表不使用流式布局。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.horizontalAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.HorizontalAlignment">
            <summary>
            控件的水平对齐方式。
            </summary>
            <remarks>
            若父控件启用了水平流式布局（<see cref = "P:GameUI.Control.Control.FlowOrientation"/>为<see cref = "F:GameUI.Enum.Orientation.Horizontal"/>），
            且设置了<seealso cref = "P:GameUI.Control.Control.HorizontalContentAlignment"/>属性，则此属性将被忽略。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.verticalAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.VerticalAlignment">
            <summary>
            控件的垂直对齐方式。
            </summary>
            <remarks>
            若父控件启用了垂直流式布局（<see cref = "P:GameUI.Control.Control.FlowOrientation"/>为<see cref = "F:GameUI.Enum.Orientation.Vertical"/>），
            且设置了<seealso cref = "P:GameUI.Control.Control.VerticalContentAlignment"/>属性，则此属性将被忽略。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.horizontalContentAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.HorizontalContentAlignment">
            <summary>
            子控件的水平对齐方式。默认值为<see cref = "F:GameUI.Enum.HorizontalContentAlignment.Center"/>。
            </summary>
            <remarks>
            <para><strong>常规容器控件：</strong></para>
            <para>若启用了水平流式布局（<see cref = "P:GameUI.Control.Control.FlowOrientation"/>为<see cref = "F:GameUI.Enum.Orientation.Horizontal"/>），且设置了此属性，则子控件的
            <see cref = "P:GameUI.Control.Control.HorizontalAlignment"/>属性将被忽略，改为使用此属性进行对齐。
            若未启用水平流式布局，且此属性和子控件的<see cref = "P:GameUI.Control.Control.HorizontalAlignment"/>属性均被设置，则优先使用子控件的
            <see cref = "P:GameUI.Control.Control.HorizontalAlignment"/>属性进行对齐。</para>
            <para><strong>Label 文本控件：</strong></para>
            <para>对于 <see cref = "T:GameUI.Control.Primitive.Label"/> 控件，此属性控制文字在 Label 内部的水平对齐方式（左对齐、居中、右对齐）。
            这是设置 Label 文字水平对齐的正确方法，而 <see cref = "P:GameUI.Control.Control.HorizontalAlignment"/> 则控制 Label 控件本身在父容器中的位置。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.verticalContentAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.VerticalContentAlignment">
            <summary>
            子控件的垂直对齐方式。默认值为<see cref = "F:GameUI.Enum.VerticalContentAlignment.Center"/>。
            </summary>
            <remarks>
            <para><strong>常规容器控件：</strong></para>
            <para>若启用了垂直流式布局（<see cref = "P:GameUI.Control.Control.FlowOrientation"/>为<see cref = "F:GameUI.Enum.Orientation.Vertical"/>），且设置了此属性，则子控件的
            <see cref = "P:GameUI.Control.Control.VerticalAlignment"/>属性将被忽略，改为使用此属性进行对齐。
            若未启用垂直流式布局，且此属性和子控件的<see cref = "P:GameUI.Control.Control.VerticalAlignment"/>属性均被设置，则优先使用子控件的
            <see cref = "P:GameUI.Control.Control.VerticalAlignment"/>属性进行对齐。</para>
            <para><strong>Label 文本控件：</strong></para>
            <para>对于 <see cref = "T:GameUI.Control.Primitive.Label"/> 控件，此属性控制文字在 Label 内部的垂直对齐方式（顶部对齐、居中、底部对齐）。
            这是设置 Label 文字垂直对齐的正确方法，而 <see cref = "P:GameUI.Control.Control.VerticalAlignment"/> 则控制 Label 控件本身在父容器中的位置。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.aspectRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.AspectRatio">
            <summary>
            控件的宽高比设置，仅在宽或高为 Auto 时生效。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Name">
            <summary>
            控件的名称。父控件可以通过此名称来查找子控件。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.isStatic">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.IsStatic">
            <summary>
            控件是否为静态（不可交互，且不会接受任何事件）。静态控件通常用于显示信息或作为布局容器，不会响应用户输入。
            静态控件依然处于事件链路中，子控件仍然可以响应事件，并可能通过静态控件的父控件来传递事件。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.IsActuallyDisabled">
            <summary>
            Gets a value indicating whether the control is disabled, either directly or indirectly through its 
            parent hierarchy.
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.disabled">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Disabled">
            <summary>
            控件是否禁用，即不可交互。禁用的控件会使其子控件也变为禁用状态。
            </summary>
            <remarks>
            由于控件禁用后会影响其子控件，因此在判断一个控件是否可以交互时，应检查<see cref = "P:GameUI.Control.Control.IsActuallyDisabled"/>属性，
            而不是直接检查此属性。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Control.IsActuallyFunctional">
            <summary>
            Gets a value indicating whether the component is functional based on its visibility and disabled state.
            The component is considered functional if it is visible, not disabled, and all its parent controls are also valid and 
            visible, and is linked to the visual tree.
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.routedEvents">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.RoutedEvents">
            <summary>
            控件的路由事件设置。决定控件是否会将某些事件传递给父控件。
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.IsLinkedToVisualTree">
             <summary>
             Gets a value indicating whether the current node is linked to a visual tree.
             </summary>
             <remarks>A node is considered linked to a visual tree if it has a valid parent chain that ultimately
             connects to a <see cref = "T:GameUI.Control.UIRoot"/>. If the node is invalid or the parent chain does not lead to a <see 
            cref = "T:GameUI.Control.UIRoot"/>, the property returns <see langword="false"/>.</remarks>
        </member>
        <member name="P:GameUI.Control.Control.IsActuallyVisible">
            <summary>
            Gets a value indicating whether the control is visible, taking into account its visibility, linkage to the
            visual tree, and the visibility of its parent controls.
            </summary>
            <remarks>This property evaluates the control's visibility by checking its own <see cref = "P:GameUI.Control.Control.Visible"/>
            property, its linkage to the visual tree, and the <see cref = "P:GameUI.Control.Control.Visible"/> property of all parent controls in its
            hierarchy. If any parent control is not visible, this property returns <see langword="false"/>.</remarks>
        </member>
        <member name="F:GameUI.Control.Control.visible">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Visible">
            <summary>
            控件是否可见。不可见的控件会使其子控件也变为不可见状态。
            </summary>
            <remarks>
            由于控件不可见后会影响其子控件，而且只有当控件直接或间接地链接到视觉树时才会被渲染，
            因此在判断一个控件是否可见时，应检查<see cref = "P:GameUI.Control.Control.IsActuallyVisible"/>属性，
            </remarks>
        </member>
        <member name="F:GameUI.Control.Control.allowDrag">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.AllowDrag">
            <summary>
            控件是否允许拖拽。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.allowDrop">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.AllowDrop">
            <summary>
            控件是否允许作为拖放目标。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.zIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ZIndex">
            <summary>
            控件的 Z 轴顺序。这决定了控件在同一父容器中的绘制顺序，数值越大，控件越靠前显示。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.background">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Background">
            <summary>
            控件的背景颜色画刷。可以是单色或是渐变色。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.desaturated">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Desaturated">
            <summary>
            控件是否为灰度（去色）显示。去色显示通常用于禁用状态或视觉效果处理。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.cornerRadius">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.CornerRadius">
            <summary>
            控件的圆角半径。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.image">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Image">
            <summary>
            控件的图片资源。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.imageMask">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ImageMask">
            <summary>
            控件的图片遮罩资源。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.imageFlipX">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ImageFlipX">
            <summary>
            控件的图片是否水平翻转。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.imageFlipY">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ImageFlipY">
            <summary>
            控件的图片是否垂直翻转。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.imageBlurLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ImageBlurLevel">
            <summary>
            控件的图片模糊等级。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.slicedEdges">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.SlicedEdges">
            <summary>
            控件的九宫格切片边距。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.opacity">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Opacity">
            <summary>
            控件的不透明度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.rotation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Rotation">
            <summary>
            控件的旋转角度。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.scale">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.Scale">
            <summary>
            控件的缩放比例。
            </summary>
        </member>
        <member name="F:GameUI.Control.Control.clipContent">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Control.ClipContent">
            <summary>
            控件是否会裁剪其子控件。
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Button">
            <summary>
            表示 UI 按钮控件。
            </summary>
            <remarks>
            按钮控件默认不会转发鼠标事件（PointerClicked, PointerDoubleClicked, PointerPressed, 
            PointerReleased, PointerEntered, PointerExited）到父控件或游戏场景，
            防止点击按钮时意外触发游戏场景中的操作。如果需要按钮转发某些鼠标事件，
            可以手动设置 <see cref = "P:GameUI.Control.Control.RoutedEvents"/> 属性。
            </remarks>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Button.DefaultTemplate">
            <summary>
            获取按钮的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Button.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlButton})">
            <summary>
            使用指定模板链接初始化按钮实例。
            </summary>
            <param name = "link">按钮模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Primitive.Button.#ctor">
            <summary>
            使用默认模板初始化按钮实例。
            </summary>
            <remarks>
            构造函数会自动设置按钮不转发任何鼠标事件，防止点击按钮时触发游戏场景中的操作。
            </remarks>
        </member>
        <member name="M:GameUI.Control.Primitive.Button.OnKeyboardAcceleratorInvokedInternal(GameUI.Control.Struct.KeyboardAccelerator)">
            <summary>
            
            </summary>
            <param name="accelerator"></param>
            <returns></returns>
        </member>
        <member name="F:GameUI.Control.Primitive.Button.imageHover">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Button.ImageHover">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Button.imagePressed">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Button.ImagePressed">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Canvas">
            <summary>
            画布控件类，提供2D图形绘制功能
            </summary>
            <remarks>
            <para>Canvas类继承自Control，提供了丰富的2D绘图API，包括：</para>
            <list type="bullet">
            <item><description>基础图形绘制（线条、圆形、矩形、三角形等）</description></item>
            <item><description>图像绘制和变换操作</description></item>
            <item><description>复杂路径绘制（包括贝塞尔曲线、圆弧等）</description></item>
            <item><description>颜色和样式管理</description></item>
            </list>
            <para>该类采用partial class设计，功能分布在多个文件中：</para>
            <list type="table">
            <item><term>Canvas.cs</term><description>基础类定义和构造函数</description></item>
            <item><term>Canvas.Draw.cs</term><description>基础绘制方法</description></item>
            <item><term>Canvas.DrawPath.cs</term><description>路径绘制功能</description></item>
            <item><term>Canvas.Properties.cs</term><description>绘制属性管理</description></item>
            </list>
            </remarks>
            <example>
            <code>
            // 创建画布实例
            var canvas = new Canvas();
            
            // 设置绘制属性
            canvas.StrokePaint = new SolidPaint(Color.Red);
            canvas.FillPaint = new SolidPaint(Color.Blue);
            canvas.StrokeSize = 2.0f;
            
            // 绘制基础图形
            canvas.DrawRectangle(10, 10, 100, 50);
            canvas.FillCircle(60, 35, 20);
            </code>
            </example>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.DefaultTemplate">
            <summary>
            获取Canvas控件的默认模板链接
            </summary>
            <value>返回指向GameDataControlCanvas类型的默认游戏链接</value>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlCanvas})">
            <summary>
            使用指定的游戏链接初始化Canvas实例
            </summary>
            <param name = "link">指向GameDataControlCanvas数据的游戏链接</param>
            <remarks>
            此构造函数将创建一个与指定数据链接绑定的Canvas控件，
            控件类型设置为SCEImportGUI.ControlType.Canvas
            </remarks>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.#ctor">
            <summary>
            使用默认模板初始化Canvas实例
            </summary>
            <remarks>
            此构造函数使用DefaultTemplate作为数据源创建Canvas控件，
            适用于不需要特定数据绑定的场景
            </remarks>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawImage(GameCore.ResourceType.Image,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            在指定位置和尺寸绘制图像
            </summary>
            <param name = "image">要绘制的图像资源</param>
            <param name = "x">图像左上角的X坐标</param>
            <param name = "y">图像左上角的Y坐标</param>
            <param name = "width">图像显示宽度</param>
            <param name = "height">图像显示高度</param>
            <remarks>
            <para>此方法将图像绘制到画布的指定位置。如果图像路径为空，则不执行绘制操作。</para>
            <para>图像会被缩放以适应指定的宽度和高度。</para>
            </remarks>
            <example>
            <code>
            var image = new Image("path/to/image.png");
            canvas.DrawImage(image, 10, 10, 100, 80);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawImage(GameCore.ResourceType.Image,System.Single,System.Single)">
            <summary>
            在指定位置绘制图像（原始尺寸）
            </summary>
            <param name = "image">要绘制的图像资源</param>
            <param name = "x">图像左上角的X坐标</param>
            <param name = "y">图像左上角的Y坐标</param>
            <remarks>
            <para>此方法将图像以原始尺寸绘制到画布的指定位置。</para>
            <para>如果图像路径为空，则不执行绘制操作。</para>
            </remarks>
            <example>
            <code>
            var image = new Image("path/to/image.png");
            canvas.DrawImage(image, 10, 10); // 在(10,10)位置绘制原尺寸图像
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawImage(GameCore.ResourceType.Image,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制图像的指定区域到画布的指定位置和尺寸
            </summary>
            <param name = "image">要绘制的图像资源</param>
            <param name = "sourceX">源图像裁剪区域的X坐标</param>
            <param name = "sourceY">源图像裁剪区域的Y坐标</param>
            <param name = "sourceWidth">源图像裁剪区域的宽度</param>
            <param name = "sourceHeight">源图像裁剪区域的高度</param>
            <param name = "x">目标位置的X坐标</param>
            <param name = "y">目标位置的Y坐标</param>
            <param name = "width">目标绘制宽度</param>
            <param name = "height">目标绘制高度</param>
            <remarks>
            <para>此方法允许选择图像的指定区域，并将其缩放绘制到目标区域。</para>
            <para>如果图像路径为空，则不执行绘制操作。</para>
            <para>源区域和目标区域可以有不同的尺寸，图像会自动缩放以适应。</para>
            </remarks>
            <example>
            <code>
            var spriteSheet = new Image("sprites.png");
            // 从精灵表中裁剪(32,0,32,32)区域，绘制到(10,10,64,64)位置并放大
            canvas.DrawImage(spriteSheet, 32, 0, 32, 32, 10, 10, 64, 64);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawImage(GameCore.ResourceType.Image,System.Drawing.RectangleF,System.Drawing.RectangleF)">
            <summary>
            使用矩形结构体绘制图像的指定区域到画布的指定位置和尺寸
            </summary>
            <param name = "image">要绘制的图像资源</param>
            <param name = "sourceRect">源图像的裁剪区域</param>
            <param name = "destRect">目标绘制区域</param>
            <remarks>
            <para>此方法是DrawImage多参数重载的便利版本，使用RectangleF结构体简化参数传递。</para>
            <para>如果图像路径为空，则不执行绘制操作。</para>
            <para>源区域和目标区域可以有不同的尺寸，图像会自动缩放以适应。</para>
            <para>此重载特别适合AI代码生成，因为参数更直观易理解。</para>
            </remarks>
            <example>
            <code>
            var spriteSheet = new Image("sprites.png");
            var sourceRect = new RectangleF(32, 0, 32, 32); // 从精灵表裁剪32x32区域
            var destRect = new RectangleF(10, 10, 64, 64);   // 绘制到64x64区域并放大
            canvas.DrawImage(spriteSheet, sourceRect, destRect);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawLine(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制从起点到终点的直线
            </summary>
            <param name = "x1">起点的X坐标</param>
            <param name = "y1">起点的Y坐标</param>
            <param name = "x2">终点的X坐标</param>
            <param name = "y2">终点的Y坐标</param>
            <remarks>
            直线的颜色由StrokePaint属性决定，线宽由StrokeSize属性决定
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Red;
            canvas.StrokeSize = 2.0f;
            canvas.DrawLine(0, 0, 100, 100);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawCircle(System.Single,System.Single,System.Single)">
            <summary>
            绘制圆形轮廓
            </summary>
            <param name = "centerX">圆心的X坐标</param>
            <param name = "centerY">圆心的Y坐标</param>
            <param name = "radius">圆的半径</param>
            <remarks>
            只绘制圆形的轮廓，不填充内部。轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Blue;
            canvas.DrawCircle(50, 50, 25);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawCircle(System.Drawing.PointF,System.Single)">
            <summary>
            绘制圆形轮廓
            </summary>
            <param name = "center">圆心坐标</param>
            <param name = "radius">圆的半径</param>
            <remarks>
            只绘制圆形的轮廓，不填充内部。轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Blue;
            canvas.DrawCircle(new PointF(50, 50), 25);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawCircle(System.Drawing.PointF,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            绘制圆弧轮廓
            </summary>
            <param name = "center">圆心坐标</param>
            <param name = "radius">圆的半径</param>
            <param name = "startAngle">起始角度（以度为单位）</param>
            <param name = "endAngle">结束角度（以度为单位）</param>
            <param name = "clockwise">是否顺时针绘制</param>
            <remarks>
            <para>绘制圆形的一段弧形轮廓。角度以度为单位，0度指向右侧（正X轴方向）。</para>
            <para>轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定。</para>
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Green;
            // 绘制从45度到135度的圆弧（四分之一圆）
            canvas.DrawCircle(new PointF(50, 50), 30, 45, 135, true);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawTriangle(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制三角形轮廓
            </summary>
            <param name = "x1">第一个顶点的X坐标</param>
            <param name = "y1">第一个顶点的Y坐标</param>
            <param name = "x2">第二个顶点的X坐标</param>
            <param name = "y2">第二个顶点的Y坐标</param>
            <param name = "x3">第三个顶点的X坐标</param>
            <param name = "y3">第三个顶点的Y坐标</param>
            <remarks>
            通过连接三个顶点来绘制三角形轮廓。轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Green;
            canvas.DrawTriangle(50, 10, 10, 90, 90, 90);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawRectangle(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制矩形轮廓
            </summary>
            <param name = "x">矩形左上角的X坐标</param>
            <param name = "y">矩形左上角的Y坐标</param>
            <param name = "width">矩形的宽度</param>
            <param name = "height">矩形的高度</param>
            <remarks>
            只绘制矩形的轮廓，不填充内部。轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = Color.Black;
            canvas.DrawRectangle(10, 10, 100, 50);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawEllipse(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制椭圆轮廓
            </summary>
            <param name = "centerX">椭圆中心的X坐标</param>
            <param name = "centerY">椭圆中心的Y坐标</param>
            <param name = "radiusX">椭圆的X轴半径</param>
            <param name = "radiusY">椭圆的Y轴半径</param>
            <remarks>
            <para>只绘制椭圆的轮廓，不填充内部。轮廓颜色由StrokePaint属性决定，线宽由StrokeWidth属性决定。</para>
            <para>椭圆通过指定不同的X轴和Y轴半径来创建，当两个半径相等时等效于圆形。</para>
            <para>椭圆的轴与坐标轴平行，如需旋转椭圆请结合变换方法使用。</para>
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = new SolidPaint(Color.Blue);
            canvas.StrokeWidth = 2.0f;
            canvas.DrawEllipse(100, 50, 60, 30); // 绘制横向椭圆轮廓
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawEllipse(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            绘制椭圆轮廓
            </summary>
            <param name = "center">椭圆中心坐标</param>
            <param name = "radiusX">椭圆的X轴半径</param>
            <param name = "radiusY">椭圆的Y轴半径</param>
            <remarks>
            <para>只绘制椭圆的轮廓，不填充内部。轮廓颜色由StrokePaint属性决定，线宽由StrokeWidth属性决定。</para>
            <para>这是DrawEllipse方法的重载版本，使用PointF结构体表示中心点，提供更简洁的API。</para>
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = new SolidPaint(Color.Green);
            canvas.DrawEllipse(new PointF(100, 50), 40, 25); // 绘制椭圆轮廓
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillCircle(System.Single,System.Single,System.Single)">
            <summary>
            绘制填充的圆形
            </summary>
            <param name = "centerX">圆心的X坐标</param>
            <param name = "centerY">圆心的Y坐标</param>
            <param name = "radius">圆的半径</param>
            <remarks>
            绘制实心圆形。填充颜色由FillPaint属性决定
            </remarks>
            <example>
            <code>
            canvas.FillPaint = Color.Red;
            canvas.FillCircle(50, 50, 25);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillEllipse(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制填充的椭圆
            </summary>
            <param name = "centerX">椭圆中心的X坐标</param>
            <param name = "centerY">椭圆中心的Y坐标</param>
            <param name = "radiusX">椭圆的X轴半径</param>
            <param name = "radiusY">椭圆的Y轴半径</param>
            <remarks>
            <para>绘制实心椭圆。填充颜色由FillPaint属性决定。</para>
            <para>椭圆通过指定不同的X轴和Y轴半径来创建，当两个半径相等时等效于圆形。</para>
            <para>椭圆的轴与坐标轴平行，如需旋转椭圆请结合变换方法使用。</para>
            <para>此方法特别适用于创建自然的形状，如云朵、鸟类身体、眼睛等有机形状。</para>
            </remarks>
            <example>
            <code>
            canvas.FillPaint = new SolidPaint(Color.Yellow);
            canvas.FillEllipse(100, 50, 60, 30); // 绘制横向椭圆
            
            // 结合渐变创建更丰富的效果
            canvas.FillPaint = new RadialGradientPaint(
                new PointF(100, 50), 0, 60,
                Color.LightBlue, Color.DarkBlue);
            canvas.FillEllipse(100, 50, 60, 30);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillEllipse(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            绘制填充的椭圆
            </summary>
            <param name = "center">椭圆中心坐标</param>
            <param name = "radiusX">椭圆的X轴半径</param>
            <param name = "radiusY">椭圆的Y轴半径</param>
            <remarks>
            <para>绘制实心椭圆。填充颜色由FillPaint属性决定。</para>
            <para>这是FillEllipse方法的重载版本，使用PointF结构体表示中心点，提供更简洁的API。</para>
            <para>特别适合在AI代码生成场景中使用，减少参数传递的复杂性。</para>
            </remarks>
            <example>
            <code>
            canvas.FillPaint = new SolidPaint(Color.Pink);
            var center = new PointF(100, 50);
            canvas.FillEllipse(center, 40, 25); // 绘制椭圆
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillTriangle(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制填充的三角形
            </summary>
            <param name = "x1">第一个顶点的X坐标</param>
            <param name = "y1">第一个顶点的Y坐标</param>
            <param name = "x2">第二个顶点的X坐标</param>
            <param name = "y2">第二个顶点的Y坐标</param>
            <param name = "x3">第三个顶点的X坐标</param>
            <param name = "y3">第三个顶点的Y坐标</param>
            <remarks>
            绘制实心三角形。填充颜色由FillPaint属性决定
            </remarks>
            <example>
            <code>
            canvas.FillPaint = Color.Blue;
            canvas.FillTriangle(50, 10, 10, 90, 90, 90);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillRectangle(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制填充的矩形
            </summary>
            <param name = "x">矩形左上角的X坐标</param>
            <param name = "y">矩形左上角的Y坐标</param>
            <param name = "width">矩形的宽度</param>
            <param name = "height">矩形的高度</param>
            <remarks>
            绘制实心矩形。填充颜色由FillPaint属性决定
            </remarks>
            <example>
            <code>
            canvas.FillPaint = new SolidPaint(Color.Yellow);
            canvas.FillRectangle(10, 10, 100, 50);
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.ClipRect(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            设置矩形裁剪区域
            </summary>
            <param name = "x">裁剪矩形左上角的X坐标</param>
            <param name = "y">裁剪矩形左上角的Y坐标</param>
            <param name = "width">裁剪矩形的宽度</param>
            <param name = "height">裁剪矩形的高度</param>
            <remarks>
            <para>设置一个矩形裁剪区域，只有在此区域内的绘制内容才会显示。</para>
            <para>此操作会影响后续所有的绘制操作，直到调用ResetState()或设置新的裁剪区域。</para>
            <para>裁剪区域可以用来创建窗口效果或限制绘制范围。</para>
            </remarks>
            <example>
            <code>
            canvas.ClipRect(10, 10, 100, 100); // 设置裁剪区域
            canvas.FillCircle(50, 50, 40); // 只有在裁剪区域内的部分会显示
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.SubtractFromClip(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            从当前裁剪区域中移除指定的矩形区域
            </summary>
            <param name = "x">要移除的矩形左上角X坐标</param>
            <param name = "y">要移除的矩形左上角Y坐标</param>
            <param name = "width">要移除的矩形宽度</param>
            <param name = "height">要移除的矩形高度</param>
            <remarks>
            <para>此方法从当前的裁剪区域中减去指定的矩形，创建一个镂空效果。</para>
            <para>在被减去的区域内，后续的绘制操作将不会显示。</para>
            <para>这可以用来创建复杂的裁剪形状或遮罩效果。</para>
            </remarks>
            <example>
            <code>
            canvas.ClipRect(0, 0, 200, 200); // 设置大的裁剪区域
            canvas.SubtractFromClip(50, 50, 100, 100); // 在中间挖一个洞
            canvas.FillRectangle(0, 0, 200, 200); // 绘制会显示边框效果
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.Rotate(System.Single)">
            <summary>
            旋转画布坐标系
            </summary>
            <param name = "degrees">旋转角度（以度为单位）</param>
            <remarks>
            <para>围绕原点旋转画布坐标系。正值表示顺时针旋转，负值表示逆时针旋转。</para>
            <para>此变换会影响后续所有绘制操作的坐标。</para>
            <para>⚠️ 注意：此方法使用角度制（度数）</para>
            </remarks>
            <example>
            <code>
            canvas.Rotate(45); // 顺时针旋转45度
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制的矩形会倾斜45度
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.RotateDegrees(System.Single)">
            <summary>
            以度为单位旋转画布坐标系（AI友好的明确方法）
            </summary>
            <param name = "degrees">旋转角度，以度为单位（0-360度）</param>
            <remarks>
            <para>这是Rotate方法的语义明确版本，专门标明使用角度制。</para>
            <para>围绕原点旋转画布坐标系。正值表示顺时针旋转，负值表示逆时针旋转。</para>
            <para>角度会自动标准化到合理范围内，避免过大的数值。</para>
            <para>对于AI代码生成场景，此方法比Rotate()更加语义明确，避免角度制/弧度制混淆。</para>
            </remarks>
            <example>
            <code>
            canvas.RotateDegrees(45f);   // 顺时针旋转45度
            canvas.RotateDegrees(-90f);  // 逆时针旋转90度
            canvas.RotateDegrees(720f);  // 旋转720度（等效于0度，完整转两圈）
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.RotateRadians(System.Single)">
            <summary>
            以弧度为单位旋转画布坐标系（AI友好的明确方法）
            </summary>
            <param name = "radians">旋转角度，以弧度为单位（0到2π弧度）</param>
            <remarks>
            <para>使用弧度制旋转画布坐标系，更适合数学计算。</para>
            <para>围绕原点旋转画布坐标系。正值表示顺时针旋转，负值表示逆时针旋转。</para>
            <para>1弧度 ≈ 57.3度，π弧度 = 180度，2π弧度 = 360度。</para>
            <para>对于AI代码生成场景，此方法提供明确的弧度制接口，避免与角度制混淆。</para>
            </remarks>
            <example>
            <code>
            canvas.RotateRadians(Math.PI / 4);    // 旋转π/4弧度（45度）
            canvas.RotateRadians(-Math.PI / 2);   // 旋转-π/2弧度（-90度）
            canvas.RotateRadians(Math.PI * 2);    // 旋转2π弧度（360度）
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.Scale(System.Single,System.Single)">
            <summary>
            缩放画布坐标系
            </summary>
            <param name = "scaleX">X轴缩放因子</param>
            <param name = "scaleY">Y轴缩放因子</param>
            <remarks>
            <para>缩放画布坐标系。值大于1会放大，值小于1会缩小。</para>
            <para>此变换会影响后续所有绘制操作的尺寸和位置。</para>
            <para>使用new关键字隐藏基类的Scale方法。</para>
            </remarks>
            <example>
            <code>
            canvas.Scale(2.0f, 1.5f); // X轴放大2倍，Y轴放大1.5倍
            canvas.DrawCircle(25, 25, 10); // 实际绘制的圆会变为椭圆
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.Translate(System.Single,System.Single)">
            <summary>
            平移画布坐标系
            </summary>
            <param name = "deltaX">X轴平移距离</param>
            <param name = "deltaY">Y轴平移距离</param>
            <remarks>
            <para>平移画布坐标系原点。正值向右/向下移动，负值向左/向上移动。</para>
            <para>此变换会影响后续所有绘制操作的位置。</para>
            </remarks>
            <example>
            <code>
            canvas.Translate(50, 30); // 原点向右移动50，向下移动30
            canvas.DrawCircle(0, 0, 10); // 实际绘制位置为(50, 30)
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.Transform(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            应用2D变换矩阵
            </summary>
            <param name = "a">变换矩阵的m11分量（X轴缩放）</param>
            <param name = "b">变换矩阵的m12分量（X轴倾斜）</param>
            <param name = "c">变换矩阵的m21分量（Y轴倾斜）</param>
            <param name = "d">变换矩阵的m22分量（Y轴缩放）</param>
            <param name = "e">变换矩阵的m31分量（X轴平移）</param>
            <param name = "f">变换矩阵的m32分量（Y轴平移）</param>
            <remarks>
            <para>应用一个3x2仿射变换矩阵到画布坐标系。</para>
            <para>变换矩阵的格式为:</para>
            <code>
            [ a  c  e ]   [ x ]
            [ b  d  f ] × [ y ]
            [ 0  0  1 ]   [ 1 ]
            </code>
            <para>此方法会与当前变换矩阵相乘，实现复合变换效果。</para>
            </remarks>
            <example>
            <code>
            // 应用缩放和平移的复合变换
            canvas.Transform(2.0f, 0, 0, 2.0f, 50, 25); // 放大2倍并平移(50,25)
            canvas.DrawRectangle(0, 0, 50, 50); // 实际绘制的矩形会被变换
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.ConcatenateTransform(System.Numerics.Matrix3x2)">
            <summary>
            连接指定的变换矩阵到当前变换
            </summary>
            <param name = "transform">要连接的3x2变换矩阵</param>
            <remarks>
            <para>将指定的变换矩阵与当前的变换矩阵相乘，实现复合变换。</para>
            <para>新的变换会应用到当前变换之后，影响后续所有的绘制操作。</para>
            <para>这是应用复杂变换（如组合旋转、缩放、平移）的推荐方法。</para>
            </remarks>
            <example>
            <code>
            var matrix = System.Numerics.Matrix3x2.CreateRotation(MathF.PI / 4); // 45度旋转
            matrix *= System.Numerics.Matrix3x2.CreateScale(1.5f); // 然后缩放1.5倍
            canvas.ConcatenateTransform(matrix);
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制变换后的矩形
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.ResetTransform">
            <summary>
            重置变换矩阵为单位矩阵
            </summary>
            <remarks>
            <para>将当前的变换矩阵重置为单位矩阵，取消所有的旋转、缩放和平移变换。</para>
            <para>调用此方法后，坐标系将恢复到初始状态。</para>
            <para>这对于在应用临时变换后恢复原始坐标系很有用。</para>
            </remarks>
            <example>
            <code>
            canvas.Rotate(45); // 旋转坐标系
            canvas.Scale(2, 2); // 缩放坐标系
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制变换后的矩形
            
            canvas.ResetTransform(); // 重置变换
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制正常的矩形
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.SaveState">
            <summary>
            保存当前画布状态到状态栈
            </summary>
            <remarks>
            <para>将当前的画布状态（包括变换矩阵、裁剪区域、绘制属性等）推入状态栈。</para>
            <para>保存的状态可以通过调用RestoreState()方法恢复。</para>
            <para>状态栈支持嵌套保存，后保存的状态会先恢复（LIFO原则）。</para>
            <para>这对于在局部区域应用临时设置后恢复原始状态很有用。</para>
            </remarks>
            <example>
            <code>
            canvas.SaveState(); // 保存当前状态
            
            canvas.Rotate(45); // 应用临时变换
            canvas.StrokePaint = Color.Red; // 应用临时颜色
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制变换后的矩形
            
            canvas.RestoreState(); // 恢复到保存的状态
            canvas.DrawRectangle(100, 0, 50, 50); // 绘制正常的矩形
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.RestoreState">
            <summary>
            从状态栈恢复之前保存的画布状态
            </summary>
            <remarks>
            <para>从状态栈中弹出最近保存的画布状态并应用到当前画布。</para>
            <para>恢复的状态包括变换矩阵、裁剪区域、绘制属性等所有画布设置。</para>
            <para>必须与SaveState()方法配对使用，确保状态栈平衡。</para>
            <para>如果状态栈为空时调用此方法，行为是未定义的。</para>
            </remarks>
            <example>
            <code>
            canvas.SaveState(); // 保存当前状态
            
            canvas.Rotate(45); // 应用临时变换
            canvas.StrokePaint = Color.Red; // 应用临时颜色
            canvas.DrawRectangle(0, 0, 50, 50); // 绘制变换后的矩形
            
            canvas.RestoreState(); // 恢复到保存的状态
            canvas.DrawRectangle(100, 0, 50, 50); // 绘制正常的矩形
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.ResetState">
            <summary>
            重置画布状态
            </summary>
            <remarks>
            清除画布上的所有绘制内容，并重置坐标变换状态
            </remarks>
            <example>
            <code>
            canvas.DrawRectangle(0, 0, 100, 100);
            canvas.ResetState(); // 清除刚才绘制的矩形，并重置坐标变换状态
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawSquare(System.Single,System.Single,System.Single)">
            <summary>
            绘制正方形轮廓
            </summary>
            <param name = "x">正方形左上角的X坐标</param>
            <param name = "y">正方形左上角的Y坐标</param>
            <param name = "size">正方形的边长</param>
            <remarks>
            <para>这是DrawRectangle方法的便利版本，专门用于绘制正方形。</para>
            <para>轮廓颜色由StrokePaint属性决定，线宽由StrokeSize属性决定。</para>
            <para>此方法对AI代码生成特别友好，减少了参数数量和出错概率。</para>
            </remarks>
            <example>
            <code>
            canvas.StrokePaint = new SolidPaint(Color.Black);
            canvas.DrawSquare(10, 10, 50); // 绘制50x50的正方形轮廓
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillSquare(System.Single,System.Single,System.Single)">
            <summary>
            绘制填充的正方形
            </summary>
            <param name = "x">正方形左上角的X坐标</param>
            <param name = "y">正方形左上角的Y坐标</param>
            <param name = "size">正方形的边长</param>
            <remarks>
            <para>这是FillRectangle方法的便利版本，专门用于绘制实心正方形。</para>
            <para>填充颜色由FillPaint属性决定。</para>
            <para>此方法对AI代码生成特别友好，语义更清晰，参数更简单。</para>
            </remarks>
            <example>
            <code>
            canvas.FillPaint = new SolidPaint(Color.Blue);
            canvas.FillSquare(10, 10, 50); // 绘制50x50的蓝色实心正方形
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.SetColors(System.Drawing.Color,System.Drawing.Color)">
            <summary>
            同时设置填充和描边颜色
            </summary>
            <param name = "fillColor">填充颜色</param>
            <param name = "strokeColor">描边颜色</param>
            <remarks>
            <para>这是一个便利方法，同时设置FillPaint和StrokePaint为指定的实心颜色。</para>
            <para>减少了AI代码生成时的重复操作，提高了代码的可读性。</para>
            <para>此方法会创建新的SolidPaint实例，适合快速设置基本颜色。</para>
            </remarks>
            <example>
            <code>
            // 一次性设置填充和描边颜色
            canvas.SetColors(Color.Blue, Color.Red);
            
            // 然后可以直接绘制图形
            canvas.FillRectangle(10, 10, 100, 50);  // 蓝色填充
            canvas.DrawRectangle(10, 70, 100, 50);  // 红色边框
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DrawPath(GameUI.Graphics.PathF)">
            <summary>
            绘制完整路径的轮廓
            </summary>
            <param name = "path">要绘制的路径对象</param>
            <remarks>
            <para>根据PathF对象中定义的路径操作序列绘制完整的路径轮廓。</para>
            <para>支持的路径操作包括：移动、直线、二次贝塞尔曲线、三次贝塞尔曲线、圆弧和路径闭合。</para>
            <para>如果路径为空或包含0个操作，则不执行任何绘制。</para>
            <para>绘制使用当前的StrokePaint和StrokeSize设置。</para>
            </remarks>
            <example>
            <code>
            var path = new PathF();
            path.MoveTo(10, 10);
            path.LineTo(100, 10);
            path.LineTo(100, 100);
            path.Close();
            
            canvas.StrokePaint = new SolidPaint(Color.Blue);
            canvas.StrokeSize = 2.0f;
            canvas.DrawPath(path); // 绘制蓝色矩形轮廓
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.FillPath(GameUI.Graphics.PathF,System.Nullable{GameUI.Control.Enum.WindingMode})">
            <summary>
            填充路径
            </summary>
            <param name = "path">要填充的路径对象</param>
            <param name = "windingMode">可选的路径缠绕模式，为null时使用DefaultPathWinding</param>
            <remarks>
            <para>根据PathF对象中定义的路径操作序列填充封闭区域。</para>
            <para>支持的路径操作包括：移动、直线、二次贝塞尔曲线、三次贝塞尔曲线、圆弧和路径闭合。</para>
            <para>如果路径为空或包含0个操作，则不执行任何填充。</para>
            <para>填充使用当前的FillPaint设置。</para>
            <para>缠绕模式决定了复杂路径的填充规则：</para>
            <list type="bullet">
            <item><description>NonZero: 非零缠绕规则，适用于大多数普通形状</description></item>
            <item><description>EvenOdd: 奇偶规则，常用于创建镂空效果</description></item>
            </list>
            <para>如果提供了windingMode参数，会临时使用该模式进行填充，之后恢复到DefaultPathWinding。</para>
            </remarks>
            <example>
            <code>
            var path = new PathF();
            path.MoveTo(10, 10);
            path.LineTo(100, 10);
            path.LineTo(100, 100);
            path.LineTo(10, 100);
            path.Close();
            
            canvas.FillPaint = new SolidPaint(Color.Blue);
            canvas.FillPath(path); // 使用默认缠绕模式填充
            
            // 或者指定特定的缠绕模式
            canvas.FillPath(path, WindingMode.EvenOdd); // 使用奇偶规则填充
            </code>
            </example>
        </member>
        <member name="T:GameUI.Control.Primitive.Canvas.BezierSegment">
            <summary>
            贝塞尔曲线段结构体
            </summary>
            <remarks>
            用于表示一个三次贝塞尔曲线段，包含起点、两个控制点和终点
            </remarks>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.BezierSegment.Start">
            <summary>贝塞尔曲线的起始点</summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.BezierSegment.Control1">
            <summary>第一个控制点</summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.BezierSegment.Control2">
            <summary>第二个控制点</summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.BezierSegment.End">
            <summary>贝塞尔曲线的结束点</summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Canvas.DisposeManaged">
            <summary>
            释放Canvas特定的托管资源
            </summary>
            <remarks>
            <para>此方法重写基类的DisposeManaged方法，用于释放Canvas特有的资源。</para>
            <para>主要执行以下清理操作：</para>
            <list type="bullet">
            <item><description>清理Canvas特定的事件订阅</description></item>
            <item><description>调用基类的DisposeManaged方法</description></item>
            </list>
            <para>继承类如需额外的资源清理，应重写此方法并确保调用base.DisposeManaged()。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.defaultPathWinding">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.DefaultPathWinding">
            <summary>
            获取或设置路径的默认缠绕模式
            </summary>
            <value>路径的缠绕模式，默认为NonZero</value>
            <remarks>
            <para>缠绕模式决定了复杂路径的填充规则：</para>
            <list type="bullet">
            <item><description>NonZero: 非零缠绕规则，适用于大多数情况</description></item>
            <item><description>EvenOdd: 奇偶规则，用于创建镂空效果</description></item>
            </list>
            <para>该属性仅接受NonZero和EvenOdd两个值，设置其他值会抛出异常。</para>
            </remarks>
            <exception cref = "T:System.ArgumentOutOfRangeException">当设置的值不是NonZero或EvenOdd时抛出</exception>
            <example>
            <code>
            canvas.DefaultPathWinding = WindingMode.EvenOdd;
            // 现在所有路径填充都会使用奇偶规则
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.fillPaint">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.FillPaint">
            <summary>
            获取或设置用于填充图形的画笔
            </summary>
            <value>填充画笔，默认为白色实心画笔</value>
            <remarks>
            <para>此属性控制所有填充操作（如FillRectangle、FillCircle、FillPath等）使用的画笔。</para>
            <para>支持的画笔类型：</para>
            <list type="bullet">
            <item><description>SolidPaint: 实心颜色画笔</description></item>
            <item><description>GradientPaint: 渐变画笔（线性、径向、盒式）</description></item>
            </list>
            <para>当设置新画笔时，会自动将其应用到底层渲染系统。</para>
            </remarks>
            <exception cref = "T:System.ArgumentException">当设置的画笔类型不受支持时抛出</exception>
            <example>
            <code>
            // 设置实心颜色
            canvas.FillPaint = new SolidPaint(Color.Red);
            
            // 设置线性渐变
            canvas.FillPaint = new LinearGradientPaint(
                new PointF(0, 0), new PointF(100, 0), 
                Color.Blue, Color.Green);
            
            canvas.FillRectangle(10, 10, 100, 50);
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.strokePaint">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.StrokePaint">
            <summary>
            获取或设置用于绘制图形轮廓的画笔
            </summary>
            <value>描边画笔，默认为黑色实心画笔</value>
            <remarks>
            <para>此属性控制所有线条和轮廓绘制操作（如DrawLine、DrawCircle、DrawRectangle等）使用的画笔。</para>
            <para>支持的画笔类型：</para>
            <list type="bullet">
            <item><description>SolidPaint: 实心颜色画笔</description></item>
            <item><description>GradientPaint: 渐变画笔（线性、径向、盒式）</description></item>
            </list>
            <para>当设置新画笔时，会自动将其应用到底层渲染系统。</para>
            <para>如果设置的画笔与当前画笔相同，则不会执行任何操作以提高性能。</para>
            </remarks>
            <exception cref = "T:System.ArgumentException">当设置的画笔类型不受支持时抛出</exception>
            <example>
            <code>
            // 设置实心颜色
            canvas.StrokePaint = new SolidPaint(Color.Blue);
            canvas.DrawCircle(50, 50, 25); // 绘制蓝色轮廓圆形
            
            // 设置线性渐变
            canvas.StrokePaint = new LinearGradientPaint(
                new PointF(0, 0), new PointF(100, 0), 
                Color.Red, Color.Green);
            canvas.DrawLine(0, 0, 100, 100);
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.strokeWidth">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.StrokeWidth">
            <summary>
            设置或获取用于绘制图形轮廓的线条宽度
            </summary>
            <value>线条宽度，默认为1.0像素</value>
            <remarks>
            <para>此属性控制所有线条和轮廓绘制操作的线条粗细。</para>
            <para>值必须大于0。较大的值会产生更粗的线条。</para>
            <para>当属性值发生变化时，会自动将新宽度设置到底层渲染系统。</para>
            <para>如果设置的宽度与当前宽度相同，则不会执行任何操作以提高性能。</para>
            </remarks>
            <example>
            <code>
            canvas.StrokeSize = 2.5f;
            canvas.DrawCircle(50, 50, 25); // 绘制2.5像素宽的圆形轮廓
            
            canvas.StrokeSize = 0.5f;
            canvas.DrawLine(0, 0, 100, 100); // 绘制0.5像素宽的细线
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.lineCap">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.LineCap">
            <summary>
            获取或设置线条端点的样式
            </summary>
            <value>线条端点样式，默认为Butt（平头端点）</value>
            <remarks>
            <para>此属性控制线条两端的形状：</para>
            <list type="bullet">
            <item><description>Butt: 平头端点，线条在端点处平齐截止</description></item>
            <item><description>Round: 圆形端点，线条端点为半圆形</description></item>
            <item><description>Square: 方形端点，线条端点向外延伸半个线宽</description></item>
            </list>
            <para>该属性影响所有线条绘制操作的外观。</para>
            </remarks>
            <example>
            <code>
            canvas.LineCap = LineCap.Round;
            canvas.StrokeSize = 10f;
            canvas.DrawLine(10, 10, 100, 10); // 绘制带圆形端点的粗线
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.lineJoin">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.LineJoin">
            <summary>
            获取或设置线条连接处的样式
            </summary>
            <value>线条连接样式，默认为Miter（斜接连接）</value>
            <remarks>
            <para>此属性控制两条线段相交时连接点的形状：</para>
            <list type="bullet">
            <item><description>Miter: 斜接连接，线条在连接处以尖角相接</description></item>
            <item><description>Round: 圆形连接，线条在连接处以圆弧相接</description></item>
            <item><description>Bevel: 斜切连接，线条在连接处以平角相接</description></item>
            </list>
            <para>该属性影响路径和多边形绘制时转角的外观。</para>
            </remarks>
            <example>
            <code>
            canvas.LineJoin = LineJoin.Round;
            canvas.StrokeSize = 8f;
            canvas.DrawTriangle(50, 10, 10, 90, 90, 90); // 绘制带圆角连接的三角形
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.miterLimit">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.MiterLimit">
            <summary>
            获取或设置斜接限制值
            </summary>
            <value>斜接限制值，默认为10.0</value>
            <remarks>
            <para>当LineJoin设置为Miter时，此属性控制斜接连接的最大长度。</para>
            <para>当两条线段的夹角很小时，斜接连接可能会变得很长。</para>
            <para>如果斜接长度超过 (线宽 * MiterLimit)，则会自动切换为斜切连接。</para>
            <para>较大的值允许更尖锐的角度，较小的值会更早切换为斜切连接。</para>
            </remarks>
            <example>
            <code>
            canvas.LineJoin = LineJoin.Miter;
            canvas.MiterLimit = 5.0f; // 限制斜接长度
            canvas.StrokeSize = 4f;
            // 绘制尖角形状，过尖的角会自动变为斜切
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.alpha">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.Alpha">
            <summary>
            获取或设置全局透明度
            </summary>
            <value>透明度值，范围为0.0到1.0，默认为1.0（完全不透明）</value>
            <remarks>
            <para>此属性控制画布上所有绘制操作的全局透明度：</para>
            <list type="bullet">
            <item><description>1.0: 完全不透明</description></item>
            <item><description>0.5: 半透明</description></item>
            <item><description>0.0: 完全透明（不可见）</description></item>
            </list>
            <para>全局透明度会与颜色自身的alpha值相乘，影响最终的渲染效果。</para>
            <para>该属性影响所有后续的绘制操作，包括填充、描边和图像绘制。</para>
            </remarks>
            <example>
            <code>
            canvas.Alpha = 0.7f; // 设置70%不透明度
            canvas.FillPaint = new SolidPaint(Color.Red);
            canvas.FillRectangle(10, 10, 100, 50); // 绘制半透明红色矩形
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.blendMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.BlendMode">
            <summary>
            获取或设置混合模式
            </summary>
            <value>混合模式，默认为SourceOver</value>
            <remarks>
            <para>混合模式决定了新绘制的内容如何与已有内容混合：</para>
            <list type="bullet">
            <item><description>SourceOver: 标准混合模式，新内容覆盖在已有内容之上</description></item>
            <item><description>SourceIn: 只在已有内容区域内绘制新内容</description></item>
            <item><description>SourceOut: 只在已有内容区域外绘制新内容</description></item>
            <item><description>SourceAtop: 新内容只替换已有内容的非透明部分</description></item>
            <item><description>Multiply: 颜色相乘混合，产生更暗的颜色</description></item>
            <item><description>Screen: 颜色相加混合，产生更亮的颜色</description></item>
            <item><description>Overlay: 覆盖混合，结合相乘和相加效果</description></item>
            </list>
            <para>不同的混合模式可以创建各种特殊的视觉效果。</para>
            </remarks>
            <example>
            <code>
            canvas.BlendMode = BlendMode.Multiply;
            canvas.FillPaint = new SolidPaint(Color.FromArgb(128, 255, 0, 0)); // 半透明红色
            canvas.FillRectangle(0, 0, 100, 100); // 与背景相乘混合
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.resolution">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.autoUpdateResolutionOnResize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.Resolution">
            <summary>
            获取或设置画布的分辨率
            </summary>
            <value>画布分辨率，默认为300x150</value>
            <remarks>
            <para>画布分辨率决定了绘制的精度和质量。</para>
            <para>更高的分辨率提供更好的绘制质量，但会消耗更多的内存和处理资源。</para>
            <para>当AutoUpdateResolutionOnResize为true时，分辨率会自动根据控件大小调整。</para>
            <para>手动设置此属性会覆盖自动调整的行为。</para>
            </remarks>
            <example>
            <code>
            canvas.Resolution = new SizeF(800, 600); // 设置高分辨率
            canvas.AutoUpdateResolutionOnResize = false; // 禁用自动调整
            </code>
            </example>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.AutoUpdateResolutionOnResize">
            <summary>
            获取或设置是否在控件大小改变时自动更新分辨率
            </summary>
            <value>是否自动更新分辨率，默认为true</value>
            <remarks>
            <para>当此属性为true时，画布分辨率会自动根据控件大小和坐标模式进行调整：</para>
            <list type="bullet">
            <item><description>DesignResolution模式：分辨率 = 控件大小 / 设备像素比</description></item>
            <item><description>CanvasResolution模式：分辨率 = 控件大小</description></item>
            </list>
            <para>设置为false时，分辨率保持固定值，不会自动调整。</para>
            <para>自动调整有助于在不同设备和缩放比例下保持一致的绘制质量。</para>
            </remarks>
            <example>
            <code>
            canvas.AutoUpdateResolutionOnResize = false; // 禁用自动调整
            canvas.Resolution = new SizeF(1920, 1080); // 设置固定分辨率
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.coordinateMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Canvas.CoordinateMode">
            <summary>
            获取或设置画布的坐标模式
            </summary>
            <value>坐标模式，默认为DesignResolution</value>
            <remarks>
            <para>坐标模式决定了画布如何处理坐标系统和像素比例：</para>
            <list type="bullet">
            <item><description>DesignResolution: 使用设计分辨率坐标系统，与框架其他控件一致，AI友好</description></item>
            <item><description>CanvasResolution: 使用Canvas原始分辨率坐标系统，适用于像素级精确绘制</description></item>
            </list>
            <para>DesignResolution模式会自动处理设备像素比例，确保在不同设备上的一致性。</para>
            <para>CanvasResolution模式提供1:1的像素精确控制，适合精密绘制需求。</para>
            </remarks>
            <example>
            <code>
            canvas.CoordinateMode = CanvasCoordinateMode.CanvasResolution;
            // 现在坐标系统将直接映射到画布像素
            canvas.DrawPixel(100, 100); // 在第100行第100列绘制像素
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Primitive.Canvas.pixelRatio">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Input">
            <summary>
            表示 UI 输入框控件。
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Input.DefaultTemplate">
            <summary>
            获取输入框的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Input.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlInput})">
            <summary>
            使用指定模板链接初始化输入框实例。
            </summary>
            <param name = "link">输入框模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Primitive.Input.#ctor">
            <summary>
            使用默认模板初始化输入框实例。
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.OnInputTextChangedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Primitive.Input.OnInputTextChanged">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.OnGotFocusHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Primitive.Input.OnGotFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.OnLostFocusHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Primitive.Input.OnLostFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.OnInputKeyDownHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Primitive.Input.OnInputKeyDown">
            <summary>
            在输入框获得焦点的前提下，按下键盘按键时触发。
            </summary>
            <remarks>
            注意：此事件与全局键盘事件 <see cref = "!:GameCore.Platform.Urho.Input.OnKeyDown"/> 不同，专门用于输入框控件。
            输入框在进行输入时会屏蔽全局按键事件，只有此事件会触发。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.OnInputKeyUpHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Control.Primitive.Input.OnInputKeyUp">
            <summary>
            在输入框获得焦点的前提下，松开键盘按键时触发。
            </summary>
            <remarks>
            注意：此事件与全局键盘事件 <see cref = "!:GameCore.Platform.Urho.Input.OnKeyUp"/> 不同，专门用于输入框控件。
            输入框在进行输入时会屏蔽全局按键事件，只有此事件会触发。
            </remarks>
        </member>
        <member name="M:GameUI.Control.Primitive.Input.DisposeManaged">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Input.Text">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.font">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Input.Font">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.fontSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Input.FontSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Input.textColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Input.TextColor">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Label">
            <summary>
            表示 UI 文本标签控件。
            </summary>
            <remarks>
            <para><strong>文字对齐方式设置：</strong></para>
            <para>Label 控件提供两套对齐属性来控制不同层面的对齐效果：</para>
            <list type="bullet">
            <item>
            <term>控件位置对齐</term>
            <description>使用 <see cref = "P:GameUI.Control.Control.HorizontalAlignment"/> 和 <see cref = "P:GameUI.Control.Control.VerticalAlignment"/> 
            来控制 Label 控件本身在父容器中的位置。</description>
            </item>
            <item>
            <term>文字内容对齐</term>
            <description>使用 <see cref = "P:GameUI.Control.Control.HorizontalContentAlignment"/> 和 <see cref = "P:GameUI.Control.Control.VerticalContentAlignment"/> 
            来控制文字在 Label 控件内部的对齐方式。这是设置文字左对齐、居中、右对齐的正确方法。</description>
            </item>
            </list>
            <para><strong>示例用法：</strong></para>
            <code>
            var titleLabel = new Label()
            {
                Text = "标题文本",
                // 控件在父容器中居中
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Top,
                // 文字在Label内部居中显示
                HorizontalContentAlignment = HorizontalContentAlignment.Center,
                VerticalContentAlignment = VerticalContentAlignment.Center
            };
            
            var leftAlignedLabel = new Label()
            {
                Text = "左对齐文本",
                // 文字在Label内部左对齐
                HorizontalContentAlignment = HorizontalContentAlignment.Left,
                VerticalContentAlignment = VerticalContentAlignment.Top
            };
            </code>
            </remarks>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.DefaultTemplate">
            <summary>
            获取标签的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Label.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlLabel})">
            <summary>
            使用指定模板链接初始化标签实例。
            </summary>
            <param name = "link">标签模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Primitive.Label.#ctor">
            <summary>
            使用默认模板初始化标签实例。
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.Text">
            <summary>
            获取或设置标签显示的文本内容。
            </summary>
            <remarks>
            <para>要控制文本的对齐方式，请使用以下属性：</para>
            <list type="bullet">
            <item><see cref = "P:GameUI.Control.Control.HorizontalContentAlignment"/> - 控制文字的水平对齐（左对齐、居中、右对齐）</item>
            <item><see cref = "P:GameUI.Control.Control.VerticalContentAlignment"/> - 控制文字的垂直对齐（顶部、居中、底部对齐）</item>
            </list>
            <para>注意：<see cref = "P:GameUI.Control.Control.HorizontalAlignment"/> 和 <see cref = "P:GameUI.Control.Control.VerticalAlignment"/> 控制的是 Label 控件本身在父容器中的位置，
            而非文字在 Label 内部的对齐方式。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.font">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.Font">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.fontSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.FontSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.textColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.TextColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.lineSpacingRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.LineSpacingRatio">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.textWrap">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.TextWrap">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.bold">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.Bold">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.italic">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.Italic">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.strokeSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.StrokeSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.strokeColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.StrokeColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.shadowOffset">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.ShadowOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.shadowColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.ShadowColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Label.textTrimming">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Label.TextTrimming">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Panel">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Panel.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlPanel})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Panel.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlPanel},ClientCaller.SCEImportGUI.ControlType)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Panel.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Panel.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.PanelScrollable">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.PanelScrollable.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlPanel})">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.PanelScrollable.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.PanelScrollable.BringItemIntoView(System.Int32)">
            <summary>
            
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="E:GameUI.Control.Primitive.PanelScrollable.OnScrollChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.PanelScrollable.DisposeManaged">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:GameUI.Control.Primitive.PanelScrollable.scrollEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.ScrollEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.PanelScrollable.scrollOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.ScrollOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.PanelScrollable.scrollBarSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.ScrollBarSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.PanelScrollable.scrollBarColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.ScrollBarColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.PanelScrollable.scrollBarValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.PanelScrollable.ScrollBarValue">
            <summary>
            In percentage, 0-1
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Particle">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Particle.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlParticle})">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Particle.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Particle.resource">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.Resource">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Particle.isPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.IsPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Particle.speed">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.Speed">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Particle.particleScale">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.ParticleScale">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Particle.particleView">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Particle.ParticleView">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Progress">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Progress.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlProgress})">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Progress.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Progress.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Progress.value">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Progress.Value">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Progress.progressionMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Progress.ProgressionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Progress.progressRotation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Progress.ProgressRotation">
            <summary>
            Only works for ProgressionMode.Clockwise and ProgressionMode.CounterClockwise, set the rotation of the progress bar fill.
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Spine">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Spine.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlSpine})">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Spine.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Spine.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Spine.isLooping">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Spine.IsLooping">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Spine.resource">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Spine.Resource">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Spine.animation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Spine.Animation">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Sprites">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Sprites.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlSprites})">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Sprites.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Sprites.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Sprites.isLooping">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Sprites.IsLooping">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Sprites.isPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Sprites.IsPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.Sprites.intervalMillisecond">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Sprites.IntervalMillisecond">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Sprites.FramePerSecond">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Struct.InputEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Struct.InputEventArgs.#ctor(System.String,GameUI.Control.Enum.UpdateSourceTrigger)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.InputEventArgs.Text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.InputEventArgs.UpdateSourceTrigger">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Struct.InputKeyEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Struct.InputKeyEventArgs.#ctor(GameCore.Platform.SDL.VirtualKey,GameCore.Platform.SDL.PointerButtons,GameCore.Platform.Urho.VirtualKeyModifiers)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.InputKeyEventArgs.Modifiers">
            <summary>
            The virtual key modifiers, such as Shift, Ctrl, or Alt, that were pressed when the event occurred.
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.InputKeyEventArgs.PointerButtons">
            <summary>
            The pointer buttons that were pressed when the event occurred. For mouse events, this indicates which mouse buttons were pressed. For finger events, differentiate between fingers by using the touching ID.
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.InputKeyEventArgs.Key">
            <summary>
            The virtual key that triggered the event.
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Struct.ScrollChangedEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Struct.ScrollChangedEventArgs.#ctor(System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.ScrollChangedEventArgs.ScrollValue">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.Struct.SizeChangedEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.Struct.SizeChangedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.SizeChangedEventArgs.WidthDP">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.SizeChangedEventArgs.HeightDP">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.Struct.SizeChangedEventArgs.Size">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Primitive.VirtualizingPanel">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.DefaultTemplate">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.MeasureDirty">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ArrangeDirty">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.MeasureInProgress">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ArrangeInProgress">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlVirtualizingPanel})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.InvalidateMeasure">
            <summary>
              Invalidates the measurement state for the element.
              This has the effect of also invalidating the arrange state for the element.
              The element will be queued for an update layout for size and position.
              For virtualizing panels, this will start the virtualization process.
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.InvalidateArrange">
            <summary>
             Invalidates the arrange state of the element, marking it as requiring a new layout pass.
             For virtualizing panels, this will start the virtualization process.
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.GenerateChildren">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.OnScrollInternal(System.Object,GameUI.Control.Primitive.Struct.ScrollChangedEventArgs)">
            <summary>
            
            </summary>
            <param name="__"></param>
            <param name="_"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "E:GameUI.Control.Primitive.VirtualizingPanel.OnChildVirtualizationPhase" -->
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.DisposeManaged">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.TickFinalizer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.CachedChildren">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.CacheStartIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.RecyclePool">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.PendingVirtualizationChildren">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.arrangedOnce">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.GetChildByItem(System.Int32)">
            <summary>
            
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.CachedRangeToRecycle(System.Int32,System.Int32)">
            <summary>
            Recycles a range of cached child elements, preparing them for reuse.
            </summary>
            <remarks>This method removes the specified range of child elements from the cache, detaches them from
            their parent,  and adds them to a recycling pool for future reuse. It also resets the item index of each
            recycled child  and removes them from the pending virtualization list.</remarks>
            <param name = "start">The zero-based index of the first child element in the range to recycle.</param>
            <param name = "count">The number of child elements to recycle, starting from the <paramref name = "start"/> index.</param>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.GetOrRecycleOrGenerateChildByItem(System.Int32)">
            <summary>
            
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.ClearCache">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.viewportSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.pageItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.cacheItemMaxCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.cacheBeforeViewportItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.cacheAfterViewportItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.logicItemsTotalSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.Measure">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Primitive.VirtualizingPanel.Arrange">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.PendingVirtualizationChildrenSwapPool">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.ReferenceItem">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.BeforeViewportPlaceHolder">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.AfterViewportPlaceHolder">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.cacheLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.itemSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Primitive.VirtualizingPanel.arrangeOnScroll">
            <summary>
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:GameUI.Control.Primitive.VirtualizingPanel.CacheLength" -->
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.CacheLengthUnit">
            <summary>
                Use this property to configure the unit portion of the before
                and after cache sizes.
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ItemSize">
            <summary>
            The item size used for virtualization. This value is used to determine the size of the items in the panel, if not specified, the size will be determined by the first item in the panel.
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ReferenceItemSize">
            <summary>
            Gets the size of the first child element in the collection, based on the current scroll orientation.
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ViewportSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.PageItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.CacheItemMaxCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.CacheBeforeViewportItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.CacheAfterViewportItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.LogicItemsTotalSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.IsVirtualizing">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ArrangeOnScroll">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Primitive.VirtualizingPanel.ItemsSource">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControl">
            <summary>
            UI 控件的数据模板基类，用于在游戏数据层定义控件的属性和行为。
            该类是数据驱动 UI 系统的核心，允许通过配置数据动态生成和更新 UI 控件。
            </summary>
            <remarks>
            GameDataControl 采用可空属性设计，只有非空值才会在 ApplyTo 时应用到控件上，
            这样可以实现部分更新和模板继承。所有具体的控件数据类（如 GameDataControlButton、
            GameDataControlLabel 等）都继承自此类。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Layout">
            <summary>
            控件的布局配置，包含位置、大小、对齐方式等布局相关属性。
            当设置时，会批量应用所有非空的布局属性到目标控件。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Event">
            <summary>
            控件的事件处理器配置，定义了控件响应的各种用户交互事件。
            包括鼠标点击、双击、进入、离开、拖放等事件的处理函数。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.IsStatic">
            <summary>
            指定控件是否为静态控件。静态控件不接收交互事件，但不影响其子控件的事件处理。
            通常用于纯展示的背景元素或布局容器。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Disabled">
            <summary>
            控件的禁用状态。禁用的控件及其所有子控件都不能接收用户输入。
            通常会配合视觉样式变化（如变灰）来提示用户。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.KeyboardAccelerators">
            <summary>
            Gets or sets the collection of keyboard accelerators associated with the control.
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.RoutedEvents">
            <summary>
            控件的事件路由配置，决定哪些事件会被控件消费，哪些会继续向父控件冒泡。
            用于实现复杂的事件传播逻辑，比如按钮的点击事件是否会冒泡到父控件。
            这个属性也影响到全局鼠标事件。如果控件吞噬了鼠标事件，则全局鼠标事件不会触发。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Visible">
            <summary>
            控件的可见性。不可见的控件及其子控件不会被渲染和参与布局计算。
            与 Opacity 为 0 不同，不可见的控件完全不占用空间。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.AllowDrag">
            <summary>
            是否允许该控件被拖拽。启用后，用户可以通过鼠标或触摸拖动该控件。
            需要配合拖拽事件处理来实现完整的拖拽功能。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.AllowDrop">
            <summary>
            是否允许其他控件拖放到该控件上。启用后，该控件可以作为拖放操作的目标。
            通常用于实现物品栏、装备槽等功能。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ZIndex">
            <summary>
            控件在同级兄弟控件中的 Z 轴排序顺序。数值越大，控件越靠前显示。
            用于控制重叠控件的显示层级，如弹出菜单、提示框等。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Background">
            <summary>
            控件的背景画刷，可以是纯色或渐变色。
            支持 SolidColorBrush、LinearGradientBrush 等多种画刷类型。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Desaturated">
            <summary>
            是否对控件进行去色（灰度）处理。通常用于表示禁用状态或特殊的视觉效果。
            去色会将控件的所有颜色转换为灰度显示。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.CornerRadius">
            <summary>
            控件的圆角半径（像素）。设置后，控件的四个角会变为圆角。
            常用于按钮、面板等控件的美化。值为 0 表示直角。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Image">
            <summary>
            控件的主图像资源路径。支持各种图片格式，路径相对于游戏资源目录。
            图像会根据控件大小和 SlicedEdges 设置进行缩放或九宫格拉伸。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ImageMask">
            <summary>
            控件的遮罩图像资源路径。遮罩图像的 Alpha 通道将用于裁剪主图像。
            常用于实现特殊形状的控件或图像效果。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ImageBlurLevel">
            <summary>
            图像的模糊等级（0-10）。0 表示不模糊，数值越大模糊程度越高。
            常用于背景虚化效果或创建毛玻璃效果。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ImageFlipX">
            <summary>
            是否水平翻转图像。启用后，图像会沿垂直轴镜像翻转。
            常用于创建对称的 UI 元素或调整图像方向。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ImageFlipY">
            <summary>
            是否垂直翻转图像。启用后，图像会沿水平轴镜像翻转。
            可与 ImageFlipX 组合使用实现 180 度旋转效果。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.SlicedEdges">
            <summary>
            九宫格切片的边距设置。定义图像哪些部分在缩放时保持原始大小（边角），
            哪些部分可以拉伸（边缘和中心）。用于制作可缩放的 UI 元素如按钮、面板边框。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Opacity">
            <summary>
            控件的不透明度（0.0-1.0）。0 表示完全透明，1 表示完全不透明。
            会影响控件及其所有子控件的透明度，可用于淡入淡出效果。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Rotation">
            <summary>
            控件的旋转角度（度）。正值表示顺时针旋转，负值表示逆时针旋转。
            旋转中心为控件的中心点，会影响控件的布局边界。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Scale">
            <summary>
            控件的缩放比例。X 和 Y 可以独立设置，实现非等比缩放。
            值为 1.0 表示原始大小，大于 1.0 表示放大，小于 1.0 表示缩小。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ClipContent">
            <summary>
            是否裁剪超出控件边界的内容。启用后，子控件超出父控件边界的部分将被裁剪。
            常用于滚动面板、列表框等需要限制内容显示区域的控件。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ItemTemplate">
            <summary>
            数据绑定的项模板。当控件设置了 ItemsSource 后，会使用此模板为每个数据项
            生成对应的子控件。用于实现列表、网格等数据驱动的 UI。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.ItemTemplateSelector">
            <summary>
            项模板选择器函数。根据不同的数据项返回不同的模板，实现异构列表。
            比如聊天列表中系统消息和玩家消息使用不同的显示模板。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.OnPostInitialization">
            <summary>
            控件初始化完成后的回调函数。在控件创建并应用模板后异步调用。
            用于执行需要控件完全初始化后才能进行的操作，如动画播放、数据加载等。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.OnVirtualizationPhase">
            <summary>
            虚拟化回调函数列表。当控件在虚拟化面板中被重用时调用。
            用于更新控件状态、重新绑定数据等，确保回收的控件正确显示新内容。
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControl.ApplyTo(GameUI.Control.Control)">
            <summary>
            将模板的所有非空属性应用到指定的控件实例。
            这是模板系统的核心方法，实现了数据到 UI 的映射。
            </summary>
            <param name = "control">要应用模板的目标控件。</param>
            <remarks>
            该方法只会应用非空属性，这样可以实现：
            1. 部分更新 - 只修改需要改变的属性
            2. 模板继承 - 子模板可以选择性覆盖父模板的属性
            3. 增量配置 - 可以多次调用来逐步配置控件
            </remarks>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControl.OverrideByOrientationApply(GameUI.Control.Control)">
            <summary>
            根据当前设备的屏幕方向应用相应的覆盖模板。
            支持响应式 UI 设计，为不同屏幕方向提供优化的布局。
            </summary>
            <param name = "control">要应用方向覆盖的控件。</param>
            <remarks>
            如果当前方向有对应的覆盖模板，会在基础模板之上再应用覆盖模板的属性。
            同时会注册方向变化事件，以便在设备旋转时自动更新布局。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.Children">
            <summary>
            子控件定义列表。仅在控件初始构造时使用，用于定义控件的静态子控件树。
            后续对此属性的修改不会影响已创建的控件实例。
            </summary>
            <remarks>
            与 ItemTemplate 不同，Children 定义的是静态的、预定义的子控件，
            而 ItemTemplate 用于动态生成数据绑定的子控件。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.OverrideByTheme">
            <summary>
            基于主题的模板覆盖字典。为不同的 UI 主题提供不同的视觉样式。
            键为主题枚举，值为该主题下的覆盖模板。
            </summary>
            <remarks>
            当前版本暂未启用，预留给未来的主题系统使用。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControl.OverrideByOrientation">
            <summary>
            基于屏幕方向的模板覆盖字典。为横屏、竖屏等不同方向提供优化的布局。
            实现响应式 UI，自动适配不同的设备方向。
            </summary>
            <remarks>
            覆盖模板会在基础模板之上应用，只需定义需要改变的属性。
            支持横屏(Landscape)、竖屏(Portrait)等多种方向。
            </remarks>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControl.CreateControl">
            <summary>
            创建该模板对应的控件实例。由具体的控件数据类实现。
            这是工厂方法模式的应用，每种控件类型都知道如何创建自己。
            </summary>
            <returns>新创建的控件实例，其类型与数据模板类型对应。</returns>
            <remarks>
            例如：GameDataControlButton.CreateControl() 返回 Button 实例，
            GameDataControlLabel.CreateControl() 返回 Label 实例。
            </remarks>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlButton">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlButton.ImageHover">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlButton.ImagePressed">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlButton.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlButton.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlButton.CreateButton">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlCanvas">
            <summary>
            Canvas控件的游戏数据类
            </summary>
            <remarks>
            <para>此类继承自GameDataControl，专门用于Canvas控件的数据管理和控件创建。</para>
            <para>它作为Canvas控件与游戏数据系统之间的桥梁，负责：</para>
            <list type="bullet">
            <item><description>Canvas控件实例的创建和初始化</description></item>
            <item><description>Canvas相关游戏数据的存储和管理</description></item>
            <item><description>与游戏数据链接系统的集成</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlCanvas.DefaultPathWinding">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlCanvas.FillPaint">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlCanvas.StrokePaint">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlCanvas.StrokeSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlCanvas.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlCanvas.CreateControl">
            <summary>
            创建Canvas控件实例
            </summary>
            <returns>基于当前数据链接创建的Canvas控件实例</returns>
            <remarks>
            <para>此方法重写基类的CreateControl方法，返回Canvas类型的具体实例。</para>
            <para>创建的控件会自动绑定到当前的数据链接(Link)。</para>
            </remarks>
            <example>
            <code>
            var canvasData = new GameDataControlCanvas();
            var canvas = canvasData.CreateControl() as Canvas;
            // 或者直接使用
            var canvas = canvasData.CreateCanvas();
            </code>
            </example>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlCanvas.CreateCanvas">
            <summary>
            创建Canvas控件的强类型版本
            </summary>
            <returns>基于当前数据链接创建的Canvas控件实例</returns>
            <remarks>
            <para>此方法提供了创建Canvas控件的强类型接口，避免了类型转换的需要。</para>
            <para>功能上等同于CreateControl()方法，但返回类型直接是Canvas而不是Control。</para>
            </remarks>
            <example>
            <code>
            var canvasData = new GameDataControlCanvas();
            var canvas = canvasData.CreateCanvas();
            
            // 可以直接使用Canvas的特定方法
            canvas.DrawCircle(50, 50, 25);
            canvas.FillColor = Color.Red;
            </code>
            </example>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlInput.InputEvents">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlInput.Text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlInput.Font">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlInput.FontSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlInput.TextColor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlInput.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlInput.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlInput.CreateInput">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlJoystickDynamic">
            <summary>
            动态游戏摇杆控件的数据模板类
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.FollowSensitivity">
            <summary>
            中心点跟随的敏感度（0-1），越大跟随越快
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.JoystickBackground">
            <summary>
            摇杆背景颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.KnobBackground">
            <summary>
            摇杆头颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.JoystickBackgroundImage">
            <summary>
            摇杆背景图像
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.KnobImage">
            <summary>
            摇杆头图像
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickDynamic.ActivationAreaBackground">
            <summary>
            激活区域背景颜色（用于调试）
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickDynamic.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickDynamic.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickDynamic.CreateJoystickDynamic">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlJoystickFloat">
            <summary>
            浮动游戏摇杆控件的数据模板类
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.JoystickBackground">
            <summary>
            摇杆背景颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.KnobBackground">
            <summary>
            摇杆头颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.JoystickBackgroundImage">
            <summary>
            摇杆背景图像
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.KnobImage">
            <summary>
            摇杆头图像
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickFloat.ActivationAreaBackground">
            <summary>
            激活区域背景颜色（用于调试）
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickFloat.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickFloat.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickFloat.CreateJoystickFloat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlJoystickNormal">
            <summary>
            普通游戏摇杆控件的数据模板类
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.JoystickBackground">
            <summary>
            摇杆背景颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.KnobBackground">
            <summary>
            摇杆头颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.JoystickBackgroundImage">
            <summary>
            摇杆背景图像
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlJoystickNormal.KnobImage">
            <summary>
            摇杆头图像
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickNormal.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickNormal.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlJoystickNormal.CreateJoystickNormal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlLabel">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.Text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.Font">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.FontSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.TextColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.LineSpacingRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.TextWrap">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.Bold">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.Italic">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.StrokeSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.StrokeColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.ShadowOffset">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.ShadowColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlLabel.TextTrimming">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlLabel.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlLabel.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlLabel.CreateLabel">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlPanel">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlPanel.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlPanel.CreatePanel">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlPanelScrollable">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollEvents">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollOrientation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollBarSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollBarColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlPanelScrollable.ScrollBarValue">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlPanelScrollable.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlPanelScrollable.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlPanelScrollable.CreatePanelScrollable">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlParticle">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlParticle.Resource">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlParticle.IsPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlParticle.Speed">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlParticle.ParticleScale">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlParticle.ParticleView">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlParticle.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlParticle.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlParticle.CreateParticle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlProgress">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlProgress.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlProgress.ProgressionMode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlProgress.ProgressRotation">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlProgress.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlProgress.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlProgress.CreateProgress">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlSpine">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSpine.IsLooping">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSpine.Resource">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSpine.Animation">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSpine.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSpine.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSpine.CreateSpine">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlSprites">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSprites.IsLooping">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSprites.IsPlaying">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSprites.IntervalMillisecond">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlSprites.FramePerSecond">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSprites.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSprites.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlSprites.CreateSprites">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlTextButton">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.Text">
            <summary>
            按钮默认文本内容
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.Font">
            <summary>
            文本字体
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.FontSize">
            <summary>
            文本字体大小
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.TextColor">
            <summary>
            文本颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.Bold">
            <summary>
            文本是否粗体
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.Italic">
            <summary>
            文本是否斜体
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.TextWrap">
            <summary>
            文本是否自动换行
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.LineSpacingRatio">
            <summary>
            行间距比例
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.TextHorizontalAlignment">
            <summary>
            文本水平对齐方式
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.TextVerticalAlignment">
            <summary>
            文本垂直对齐方式
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.StrokeSize">
            <summary>
            文本描边大小
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.StrokeColor">
            <summary>
            文本描边颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.ShadowOffset">
            <summary>
            文本阴影偏移
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlTextButton.ShadowColor">
            <summary>
            文本阴影颜色
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlTextButton.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlTextButton.CreateControl">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlTextButton.CreateTextButton">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.GameDataControlVirtualizingPanel">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlVirtualizingPanel.CacheLength">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlVirtualizingPanel.CacheLengthUnit">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlVirtualizingPanel.ItemSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.GameDataControlVirtualizingPanel.ArrangeOnScroll">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.GameDataControlVirtualizingPanel.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.Struct.Event">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerClicked">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerDoubleClicked">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerEntered">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerExited">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerPressed">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerReleased">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnPointerCapturedMove">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnDrag">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnDrop">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Event.OnSizeChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.Struct.Event.ApplyTo(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.Struct.InputEvents">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.InputEvents.OnInputTextChanged">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.InputEvents.OnGotFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.InputEvents.OnLostFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.InputEvents.OnInputKeyDown">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.InputEvents.OnInputKeyUp">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.Struct.InputEvents.ApplyTo(GameUI.Control.Primitive.Input)">
            <summary>
            
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.Struct.Layout">
            <summary>
            表示控件的布局属性集合，可用于批量设置控件的布局相关属性。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.Position">
            <summary>
            控件的布局位置。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.PositionType">
            <summary>
            控件的布局定位类型，决定 <see cref = "P:GameUI.Control.Data.Struct.Layout.Position"/> 的含义。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.Margin">
            <summary>
            控件的外边距。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.Padding">
            <summary>
            控件的内边距。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.Width">
            <summary>
            控件的宽度（支持 Auto）。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.Height">
            <summary>
            控件的高度（支持 Auto）。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.WidthStretchRatio">
            <summary>
            控件在父容器中的宽度拉伸比例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.HeightStretchRatio">
            <summary>
            控件在父容器中的高度拉伸比例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.WidthCompactRatio">
            <summary>
            控件在父容器中的宽度收缩比例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.HeightCompactRatio">
            <summary>
            控件在父容器中的高度收缩比例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.FlowOrientation">
            <summary>
            控件的流式布局方向。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.HorizontalAlignment">
            <summary>
            控件的水平对齐方式。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.VerticalAlignment">
            <summary>
            控件的垂直对齐方式。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.HorizontalContentAlignment">
            <summary>
            子控件的水平对齐方式。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.VerticalContentAlignment">
            <summary>
            子控件的垂直对齐方式。
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.Layout.AspectRatio">
            <summary>
            控件的宽高比设置，仅在宽或高为 Auto 时生效。
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.Struct.Layout.ApplyTo(GameUI.Control.Control)">
            <summary>
            批量应用布局属性到指定控件。
            </summary>
            <param name = "control">要应用布局的控件。</param>
        </member>
        <member name="T:GameUI.Control.Data.Struct.PanelScrollableEvents">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Data.Struct.PanelScrollableEvents.OnScrollChangedHandler">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Data.Struct.PanelScrollableEvents.ApplyTo(GameUI.Control.Primitive.PanelScrollable)">
            <summary>
            
            </summary>
            <param name="panelScrollable"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Data.Struct.TemplateOverride">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.TemplateOverride.ThemeOverride">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Data.Struct.TemplateOverride.OrientationOverride">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Enum.Auto`1">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.#ctor(GameUI.Control.Enum.AutoMode,`0)">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Enum.Auto`1.IsAuto">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Enum.Auto`1.Mode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Enum.Auto`1.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.Equals(GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Equality(GameUI.Control.Enum.Auto{`0},GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Inequality(GameUI.Control.Enum.Auto{`0},GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Equality(GameUI.Control.Enum.Auto{`0},`0)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Inequality(GameUI.Control.Enum.Auto{`0},`0)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Equality(`0,GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Inequality(`0,GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Equality(GameUI.Control.Enum.Auto{`0},GameUI.Control.Enum.AutoMode)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Inequality(GameUI.Control.Enum.Auto{`0},GameUI.Control.Enum.AutoMode)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Equality(GameUI.Control.Enum.AutoMode,GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Inequality(GameUI.Control.Enum.AutoMode,GameUI.Control.Enum.Auto{`0})">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Implicit(GameUI.Control.Enum.AutoMode)~GameUI.Control.Enum.Auto{`0}">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Implicit(`0)~GameUI.Control.Enum.Auto{`0}">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.op_Implicit(GameUI.Control.Enum.Auto{`0})~`0">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.Auto`1.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Enum.BlendMode">
            <summary>
            定义绘制内容与已有内容的混合模式
            </summary>
            <remarks>
            <para>混合模式决定了新绘制的内容如何与画布上已有的内容进行混合。</para>
            <para>不同的混合模式可以创建各种视觉效果，从简单的覆盖到复杂的颜色混合。</para>
            <para>混合模式基于Porter-Duff合成操作和传统的图形混合算法。</para>
            </remarks>
            <example>
            <code>
            // 标准覆盖模式
            canvas.BlendMode = BlendMode.SourceOver;
            
            // 相乘模式，产生更暗的颜色
            canvas.BlendMode = BlendMode.Multiply;
            
            // 异或模式，创建特殊效果
            canvas.BlendMode = BlendMode.Xor;
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.SourceOver">
            <summary>
            源覆盖模式（默认）
            </summary>
            <remarks>
            新绘制的内容覆盖在已有内容之上。这是最常用的标准混合模式，新内容会根据其透明度与背景混合。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.SourceIn">
            <summary>
            源内部模式
            </summary>
            <remarks>
            新内容仅在已有内容的不透明区域内显示。透明区域不会显示新内容。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.SourceOut">
            <summary>
            源外部模式
            </summary>
            <remarks>
            新内容仅在已有内容的透明区域内显示。不透明区域不会显示新内容。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.SourceAtop">
            <summary>
            源顶部模式
            </summary>
            <remarks>
            新内容替换已有内容的不透明部分，透明部分保持不变。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.DestinationOver">
            <summary>
            目标覆盖模式
            </summary>
            <remarks>
            已有内容覆盖在新内容之上。与SourceOver相反，背景内容优先显示。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.DestinationIn">
            <summary>
            目标内部模式
            </summary>
            <remarks>
            已有内容仅在新内容的不透明区域内显示。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.DestinationOut">
            <summary>
            目标外部模式
            </summary>
            <remarks>
            已有内容仅在新内容的透明区域内显示。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.DestinationAtop">
            <summary>
            目标顶部模式
            </summary>
            <remarks>
            已有内容替换新内容的不透明部分。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.Lighten">
            <summary>
            变亮模式
            </summary>
            <remarks>
            选择新内容和已有内容中较亮的颜色。每个颜色通道独立比较，结果是两者中较大的值。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.Copy">
            <summary>
            复制模式
            </summary>
            <remarks>
            新内容完全替换已有内容，忽略透明度混合。这是最直接的替换操作。
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.BlendMode.Xor">
            <summary>
            异或模式
            </summary>
            <remarks>
            对新内容和已有内容执行异或操作。重叠的不透明区域变为透明，其他区域正常显示。常用于创建特殊的视觉效果。
            </remarks>
        </member>
        <member name="T:GameUI.Control.Enum.CanvasCoordinateMode">
            <summary>
            Canvas坐标系统模式
            </summary>
            <remarks>
            <para>坐标系统模式决定了Canvas如何处理绘制坐标和设备像素的映射关系。</para>
            <para>不同的坐标模式适用于不同的使用场景：</para>
            <list type="bullet">
            <item><description>DesignResolution: 适用于一般UI开发，与其他控件保持一致</description></item>
            <item><description>CanvasResolution: 适用于像素级精确绘制，如图像处理或精密图形</description></item>
            </list>
            <para>选择合适的坐标模式对于确保在不同设备上的正确显示效果至关重要。</para>
            </remarks>
            <example>
            <code>
            // 使用设计分辨率模式（推荐用于一般UI）
            canvas.CoordinateMode = CanvasCoordinateMode.DesignResolution;
            canvas.DrawRectangle(10, 10, 100, 50); // 坐标会自动适配不同DPI
            
            // 使用Canvas分辨率模式（用于像素级精确控制）
            canvas.CoordinateMode = CanvasCoordinateMode.CanvasResolution;
            canvas.DrawPixel(100, 100); // 直接映射到画布像素
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Enum.CanvasCoordinateMode.DesignResolution">
            <summary>
            使用设计分辨率坐标系统（与框架其他控件一致，AI友好）
            </summary>
            <remarks>
            <para>在此模式下，Canvas使用与框架其他控件相同的坐标系统。</para>
            <para>坐标会自动根据设备像素比例进行缩放，确保在不同DPI设备上的一致显示效果。</para>
            <para>这是推荐的默认模式，特别适合UI开发和与其他控件混合使用的场景。</para>
            <para>此模式对AI辅助开发更友好，因为坐标系统更直观。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.CanvasCoordinateMode.CanvasResolution">
            <summary>
            使用Canvas原始分辨率坐标系统，当用户期望实现像素级精确绘制时使用
            </summary>
            <remarks>
            <para>在此模式下，Canvas坐标直接映射到画布像素，提供1:1的像素精确控制。</para>
            <para>不进行DPI缩放，适合需要精确像素控制的场景，如图像处理、像素艺术或技术绘图。</para>
            <para>在高DPI设备上，相同的坐标值会显得更小，需要开发者手动处理缩放。</para>
            <para>适合高精度绘制需求和需要直接操作像素的专业应用。</para>
            </remarks>
        </member>
        <member name="T:GameUI.Control.Enum.RoutedEventsExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Enum.RoutedEventsExtensions.HasAll(GameUI.Control.Enum.RoutedEvents,GameUI.Control.Enum.RoutedEvents)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Enum.RoutedEventsExtensions.HasAny(GameUI.Control.Enum.RoutedEvents,GameUI.Control.Enum.RoutedEvents)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Enum.RoutedEventsExtensions.HasNone(GameUI.Control.Enum.RoutedEvents,GameUI.Control.Enum.RoutedEvents)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Enum.RoutedEventsExtensions.Except(GameUI.Control.Enum.RoutedEvents,GameUI.Control.Enum.RoutedEvents)">
            <summary>
            Returns a new RoutedEvents value with the specified events removed.
            </summary>
            <param name = "value">The original RoutedEvents value.</param>
            <param name = "except">The events to remove from the original value.</param>
            <returns>A new RoutedEvents value with the specified events removed.</returns>
            <example>
            <code>
            var events = RoutedEvents.All.Except(RoutedEvents.PointerClicked);
            </code>
            </example>
        </member>
        <member name="T:GameUI.Control.Enum.ScrollUnit">
            <summary>
            Enumeration that specifies the scrollUnit of the VirtualizingStackPanel. 
            Used by <see cref = "!:VirtualizingPanel.ScrollUnit"/>.
            </summary>
        </member>
        <member name="T:GameUI.Control.Enum.VirtualizationMode">
            <summary>
            Enumeration that specifies the virtualization mode of the VirtualizingPanel. 
            Used by <see cref = "!:VirtualizingPanel.VirtualizationMode"/>.
            </summary>
        </member>
        <member name="F:GameUI.Control.Enum.VirtualizationMode.Standard">
            <summary>
                Standard virtualization mode -- containers are thrown away when offscreen.
            </summary>
        </member>
        <member name="F:GameUI.Control.Enum.VirtualizationMode.Recycling">
            <summary>
                Recycling virtualization mode -- containers are re-used when offscreen.
            </summary>
        </member>
        <member name="T:GameUI.Control.Enum.WindingMode">
            <summary>
            定义路径填充时使用的缠绕模式
            </summary>
            <remarks>
            <para>缠绕模式决定了在填充复杂路径（如自相交路径）时，哪些区域应该被填充。</para>
            <para>不同的缠绕模式适用于不同的绘制需求：</para>
            <list type="bullet">
            <item><description>NonZero: 适用于大多数普通形状的填充</description></item>
            <item><description>EvenOdd: 常用于创建镂空效果或复杂的几何图案</description></item>
            </list>
            </remarks>
            <example>
            <code>
            // 使用非零缠绕规则填充普通形状
            canvas.DefaultPathWinding = WindingMode.NonZero;
            
            // 使用奇偶规则创建镂空效果
            canvas.DefaultPathWinding = WindingMode.EvenOdd;
            canvas.FillPath(complexPath); // 自相交区域会显示镂空效果
            </code>
            </example>
        </member>
        <member name="F:GameUI.Control.Enum.WindingMode.NonZero">
            <summary>
            非零缠绕规则
            </summary>
            <remarks>
            <para>使用非零缠绕规则来确定填充区域。此规则通过计算路径围绕某点的净缠绕数来决定是否填充。</para>
            <para>如果净缠绕数不为零，则填充该区域；如果为零，则不填充。</para>
            <para>这是最常用的填充规则，适用于大多数普通几何形状。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Control.Enum.WindingMode.EvenOdd">
            <summary>
            奇偶缠绕规则
            </summary>
            <remarks>
            <para>使用奇偶规则来确定填充区域。此规则通过计算从某点向任意方向发射的射线与路径边界的交点数量来决定是否填充。</para>
            <para>如果交点数量为奇数，则填充该区域；如果为偶数，则不填充。</para>
            <para>这种规则常用于创建镂空效果，特别适合复杂的自相交路径。</para>
            </remarks>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickDynamic">
            <summary>
            动态游戏摇杆控件。跟随手指/鼠标移动，没有固定中心点，中心点会随着手指移动而调整。
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.DefaultTemplate">
            <summary>
            获取摇杆的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickDynamic.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlJoystickDynamic})">
            <summary>
            使用指定模板链接初始化摇杆实例。
            </summary>
            <param name = "link">摇杆模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickDynamic.#ctor">
            <summary>
            使用默认模板初始化摇杆实例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.InputValue">
            <summary>
            摇杆的当前输入值，范围为 (-1, -1) 到 (1, 1)
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.IsActive">
            <summary>
            摇杆是否当前激活
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.FollowSensitivity">
            <summary>
            中心点跟随的敏感度（0-1），越大跟随越快
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickDynamic.ValueChanged">
            <summary>
            摇杆值改变时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickDynamic.Activated">
            <summary>
            摇杆激活时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickDynamic.Deactivated">
            <summary>
            摇杆停用时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickDynamic.CenterChanged">
            <summary>
            摇杆中心位置改变时触发的事件
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.backgroundControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.knobControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.activationArea">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.isDragging">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.dynamicCenterPosition">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.lastPointerPosition">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickDynamic.initialPointerPosition">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickDynamic.GenerateChildren">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickDynamic.UpdateAppearance">
            <summary>
            更新摇杆的外观设置
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickDynamic.ForceDeactivate">
            <summary>
            手动停用摇杆
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickDynamic.CurrentCenterPosition">
            <summary>
            获取当前动态中心位置
            </summary>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickCenterChangedEventArgs">
            <summary>
            摇杆中心位置改变事件参数
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickCenterChangedEventArgs.OldCenter">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickCenterChangedEventArgs.NewCenter">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickCenterChangedEventArgs.#ctor(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickFloat">
            <summary>
            浮动游戏摇杆控件。在用户触摸/点击位置动态出现，位置固定直到操作结束。
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.DefaultTemplate">
            <summary>
            获取摇杆的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickFloat.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlJoystickFloat})">
            <summary>
            使用指定模板链接初始化摇杆实例。
            </summary>
            <param name = "link">摇杆模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickFloat.#ctor">
            <summary>
            使用默认模板初始化摇杆实例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.InputValue">
            <summary>
            摇杆的当前输入值，范围为 (-1, -1) 到 (1, 1)
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickFloat.IsActive">
            <summary>
            摇杆是否当前可见/激活
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickFloat.ValueChanged">
            <summary>
            摇杆值改变时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickFloat.Activated">
            <summary>
            摇杆激活时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickFloat.Deactivated">
            <summary>
            摇杆停用时触发的事件
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickFloat.backgroundControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickFloat.knobControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickFloat.activationArea">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickFloat.isDragging">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickFloat.floatCenterPosition">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickFloat.GenerateChildren">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickFloat.UpdateAppearance">
            <summary>
            更新摇杆的外观设置
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickFloat.ForceDeactivate">
            <summary>
            手动停用摇杆
            </summary>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickActivatedEventArgs">
            <summary>
            摇杆激活事件参数
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickActivatedEventArgs.Position">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickActivatedEventArgs.#ctor(System.Numerics.Vector2)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickNormal">
            <summary>
            普通游戏摇杆控件。具有固定的中心位置，摇杆头可以在固定半径内拖动。
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.DefaultTemplate">
            <summary>
            获取摇杆的默认模板链接。
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlJoystickNormal})">
            <summary>
            使用指定模板链接初始化摇杆实例。
            </summary>
            <param name = "link">摇杆模板数据链接。</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.#ctor">
            <summary>
            使用默认模板初始化摇杆实例。
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.InputValue">
            <summary>
            摇杆的当前输入值，范围为 (-1, -1) 到 (1, 1)
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.Radius">
            <summary>
            摇杆操作半径（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.KnobSize">
            <summary>
            摇杆头的大小（像素）
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.IsEnabled">
            <summary>
            是否启用摇杆功能
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickNormal.ValueChanged">
            <summary>
            摇杆值改变时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickNormal.DragStarted">
            <summary>
            摇杆开始拖动时触发的事件
            </summary>
        </member>
        <member name="E:GameUI.Control.Advanced.JoystickNormal.DragEnded">
            <summary>
            摇杆结束拖动时触发的事件
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickNormal.backgroundControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickNormal.knobControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickNormal.isDragging">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.JoystickNormal.centerPosition">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.GenerateChildren">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.UpdateAppearance">
            <summary>
            更新摇杆的外观设置
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.BackgroundPanel">
            <summary>
            获取摇杆背景控件
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.KnobPanel">
            <summary>
            获取摇杆头控件
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickNormal.IsDragging">
            <summary>
            摇杆是否正在被拖动
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.SetBackgroundStyle(GameUI.Brush.ColorBrush)">
            <summary>
            设置摇杆背景样式
            </summary>
            <param name = "background">背景画刷</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.SetKnobStyle(GameUI.Brush.ColorBrush)">
            <summary>
            设置摇杆头样式
            </summary>
            <param name = "background">背景画刷</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.SetBackgroundImage(System.String)">
            <summary>
            设置摇杆背景图像
            </summary>
            <param name = "imagePath">图像路径</param>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickNormal.SetKnobImage(System.String)">
            <summary>
            设置摇杆头图像
            </summary>
            <param name = "imagePath">图像路径</param>
        </member>
        <member name="T:GameUI.Control.Advanced.JoystickValueChangedEventArgs">
            <summary>
            摇杆值改变事件参数
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickValueChangedEventArgs.OldValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.JoystickValueChangedEventArgs.NewValue">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.JoystickValueChangedEventArgs.#ctor(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Advanced.TextButton">
            <summary>
            表示带有内置文本支持的高级按钮控件
            </summary>
            <remarks>
            TextButton是对Button的封装，内部管理一个Label子控件来显示文本。
            它提供了更简洁的API来处理带文本的按钮，避免手动管理Label子控件。
            相比传统的Button + Label组合，TextButton提供了统一的文本设置接口。
            </remarks>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.DefaultTemplate">
            <summary>
            获取TextButton的默认模板链接
            </summary>
        </member>
        <member name="F:GameUI.Control.Advanced.TextButton._textLabel">
            <summary>
            内部的Label控件，用于显示文本
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.TextButton.#ctor(GameData.IGameLink{GameUI.Control.Data.GameDataControlTextButton})">
            <summary>
            使用指定模板链接初始化TextButton实例
            </summary>
            <param name = "link">按钮模板数据链接</param>
        </member>
        <member name="M:GameUI.Control.Advanced.TextButton.#ctor">
            <summary>
            使用默认模板初始化TextButton实例
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.TextButton.#ctor(System.String)">
            <summary>
            使用指定文本初始化TextButton实例
            </summary>
            <param name = "text">按钮文本</param>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.Text">
            <summary>
            获取或设置按钮显示的文本内容
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.Font">
            <summary>
            获取或设置文本字体
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.FontSize">
            <summary>
            获取或设置文本字体大小
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.TextColor">
            <summary>
            获取或设置文本颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.Bold">
            <summary>
            获取或设置文本是否为粗体
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.Italic">
            <summary>
            获取或设置文本是否为斜体
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.TextWrap">
            <summary>
            获取或设置文本是否自动换行
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.LineSpacingRatio">
            <summary>
            获取或设置行间距比例
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.TextHorizontalAlignment">
            <summary>
            获取或设置文本的水平内容对齐方式
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.TextVerticalAlignment">
            <summary>
            获取或设置文本的垂直内容对齐方式
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.StrokeSize">
            <summary>
            获取或设置文本描边大小
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.StrokeColor">
            <summary>
            获取或设置文本描边颜色
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.ShadowOffset">
            <summary>
            获取或设置文本阴影偏移
            </summary>
        </member>
        <member name="P:GameUI.Control.Advanced.TextButton.ShadowColor">
            <summary>
            获取或设置文本阴影颜色
            </summary>
        </member>
        <member name="M:GameUI.Control.Advanced.TextButton.Dispose(System.Boolean)">
            <summary>
            重写Dispose方法，确保正确清理内部Label
            </summary>
        </member>
        <member name="T:GameUI.Control.Extensions.BuilderExtensions">
            <summary>
            现代化的控件构建扩展，提供直观、一致的API
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Data``1(``0,System.Object)">
            <summary>
            设置控件的数据上下文
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Show``1(``0)">
            <summary>
            显示控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Hide``1(``0)">
            <summary>
            隐藏控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Visibility``1(``0,System.Boolean)">
            <summary>
            设置控件可见性
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Enable``1(``0)">
            <summary>
            启用控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Disable``1(``0)">
            <summary>
            禁用控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Enabled``1(``0,System.Boolean)">
            <summary>
            设置控件启用状态
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.AddToRoot``1(``0)">
            <summary>
            添加控件到UI根容器（视觉树根部）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.AddToParent``1(``0,GameUI.Control.Control)">
            <summary>
            添加控件到指定父容器
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.AddToParent``1(``0,GameUI.Control.Control,System.Int32)">
            <summary>
            添加控件到指定父容器的指定位置
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.RemoveFromParent``1(``0)">
            <summary>
            从父容器中移除控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.FullScreen``1(``0)">
            <summary>
            让控件占据整个屏幕/视口大小（响应式）
            </summary>
            <remarks>
            使用flex拉伸机制而非固定尺寸，能自动响应屏幕旋转和分辨率变化
            </remarks>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.ScreenStretch``1(``0,System.Single,System.Single)">
            <summary>
            让控件占据屏幕的指定拉伸比例（响应式）
            </summary>
            <remarks>
            使用flex拉伸机制，能自动响应屏幕变化
            </remarks>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Background``1(``0,System.Drawing.Color)">
            <summary>
            设置背景颜色
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Background``1(``0,GameUI.Brush.ColorBrush)">
            <summary>
            设置背景画刷
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Background``1(``0,GameUI.Brush.SolidColorBrush)">
            <summary>
            设置背景画刷（固定颜色）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Opacity``1(``0,System.Single)">
            <summary>
            设置透明度
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Rounded``1(``0,System.Single)">
            <summary>
            设置圆角半径
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Layer``1(``0,System.Int32)">
            <summary>
            设置Z轴层级
            </summary>
        </member>
        <member name="T:GameUI.Control.Extensions.BuilderExtensions.ITextControl">
            <summary>
            文本控件的统一接口
            </summary>
        </member>
        <member name="P:GameUI.Control.Extensions.BuilderExtensions.ITextControl.Text">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Extensions.BuilderExtensions.ITextControl.TextColor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Extensions.BuilderExtensions.ITextControl.FontSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Extensions.BuilderExtensions.ITextControl.Bold">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Extensions.BuilderExtensions.ITextControl.Italic">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Text``1(``0,System.String)">
            <summary>
            设置文本内容
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.TextColor``1(``0,System.Drawing.Color)">
            <summary>
            设置文本颜色
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.FontSize``1(``0,System.Int32)">
            <summary>
            设置字体大小
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Bold``1(``0,System.Boolean)">
            <summary>
            设置粗体文本
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Italic``1(``0,System.Boolean)">
            <summary>
            设置斜体文本
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.TextStyle``1(``0,System.Nullable{System.Int32},System.Nullable{System.Drawing.Color},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            设置文本样式组合
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Text(GameUI.Control.Primitive.Label,System.String)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.TextColor(GameUI.Control.Primitive.Label,System.Drawing.Color)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.FontSize(GameUI.Control.Primitive.Label,System.Int32)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Bold(GameUI.Control.Primitive.Label,System.Boolean)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="bold"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Italic(GameUI.Control.Primitive.Label,System.Boolean)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="italic"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Text(GameUI.Control.Advanced.TextButton,System.String)">
            <summary>
            
            </summary>
            <param name="button"></param>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.TextColor(GameUI.Control.Advanced.TextButton,System.Drawing.Color)">
            <summary>
            
            </summary>
            <param name="button"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.FontSize(GameUI.Control.Advanced.TextButton,System.Int32)">
            <summary>
            
            </summary>
            <param name="button"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Bold(GameUI.Control.Advanced.TextButton,System.Boolean)">
            <summary>
            
            </summary>
            <param name="button"></param>
            <param name="bold"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Italic(GameUI.Control.Advanced.TextButton,System.Boolean)">
            <summary>
            
            </summary>
            <param name="button"></param>
            <param name="italic"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Add``1(``0,GameUI.Control.Control)">
            <summary>
            添加子控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Add``1(``0,GameUI.Control.Control[])">
            <summary>
            添加多个子控件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Add``1(``0,System.Collections.Generic.IEnumerable{GameUI.Control.Control})">
            <summary>
            添加子控件集合
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Click``1(``0,System.Action)">
            <summary>
            设置点击事件（统一的命名）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Click``1(``0,System.EventHandler{GameUI.Control.Struct.PointerEventArgs})">
            <summary>
            设置详细点击事件
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.Scrollable(GameUI.Control.Primitive.PanelScrollable,System.Boolean)">
            <summary>
            启用滚动
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.VScroll(GameUI.Control.Primitive.PanelScrollable)">
            <summary>
            设置垂直滚动
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.HScroll(GameUI.Control.Primitive.PanelScrollable)">
            <summary>
            设置水平滚动
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.ScrollBar(GameUI.Control.Primitive.PanelScrollable,System.Single,System.Nullable{System.Drawing.Color})">
            <summary>
            设置滚动条样式
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.BuilderExtensions.ScrollTo(GameUI.Control.Primitive.PanelScrollable,System.Single)">
            <summary>
            设置滚动位置（0-1之间）
            </summary>
        </member>
        <member name="T:GameUI.Control.Extensions.UI">
            <summary>
            现代化的UI构建器，提供简洁的静态方法
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Panel">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Button">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.TextButton">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.TextButton(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Label">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Label(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.ScrollPanel">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Title(System.String,System.Int32)">
            <summary>
            创建标题
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Subtitle(System.String,System.Int32)">
            <summary>
            创建副标题
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Body(System.String,System.Int32)">
            <summary>
            创建正文
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Caption(System.String,System.Int32)">
            <summary>
            创建说明文字
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Primary(System.String)">
            <summary>
            创建主要按钮
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Secondary(System.String)">
            <summary>
            创建次要按钮
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Success(System.String)">
            <summary>
            创建成功按钮
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Danger(System.String)">
            <summary>
            创建危险按钮
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.VStack(GameUI.Control.Control[])">
            <summary>
            垂直堆叠
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.VStack(System.Single,GameUI.Control.Control[])">
            <summary>
            垂直堆叠（带间距）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.HStack(GameUI.Control.Control[])">
            <summary>
            水平堆叠
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.HStack(System.Single,GameUI.Control.Control[])">
            <summary>
            水平堆叠（带间距）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Center(GameUI.Control.Control)">
            <summary>
            居中容器
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Card(GameUI.Control.Control,System.Single)">
            <summary>
            卡片容器
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.VScroll(GameUI.Control.Control)">
            <summary>
            垂直滚动容器
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.HScroll(GameUI.Control.Control)">
            <summary>
            水平滚动容器
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.List(GameUI.Control.Control[])">
            <summary>
            列表容器（带样式的垂直滚动）
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.HDivider(System.Single,System.Nullable{System.Drawing.Color})">
            <summary>
            水平分隔线
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.VDivider(System.Single,System.Nullable{System.Drawing.Color})">
            <summary>
            垂直分隔线
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Space(System.Single)">
            <summary>
            固定间距
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.UI.Spacer">
            <summary>
            弹性间距（占用剩余空间）
            </summary>
        </member>
        <member name="T:GameUI.Control.Extensions.Colors">
            <summary>
            现代化设计系统颜色
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Primary">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Secondary">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Success">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Warning">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Error">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Background">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Surface">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Elevated">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnPrimary">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnSecondary">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnSuccess">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnWarning">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnError">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.OnBackground">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Divider">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.ScrollBar">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Disabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Extensions.Colors.Transparent">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.Extensions.LayoutExtensions">
            <summary>
            为控件提供Flexbox风格的布局扩展方法，使布局更加直观和AI友好
            </summary>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Size``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的宽度和高度
            </summary>
            <param name = "control">目标控件</param>
            <param name = "width">宽度</param>
            <param name = "height">高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Width``1(``0,System.Single)">
            <summary>
            设置控件的宽度
            </summary>
            <param name = "control">目标控件</param>
            <param name = "width">宽度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Height``1(``0,System.Single)">
            <summary>
            设置控件的高度
            </summary>
            <param name = "control">目标控件</param>
            <param name = "height">高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AutoWidth``1(``0)">
            <summary>
            设置控件宽度为自动
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AutoHeight``1(``0)">
            <summary>
            设置控件高度为自动
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AutoSize``1(``0)">
            <summary>
            设置控件宽高都为自动
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Position``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的位置
            </summary>
            <param name = "control">目标控件</param>
            <param name = "x">X坐标</param>
            <param name = "y">Y坐标</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.PositionType``1(``0,GameUI.Enum.UIPositionType)">
            <summary>
            设置控件的位置类型
            </summary>
            <param name = "control">目标控件</param>
            <param name = "positionType">位置类型</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Margin``1(``0,GameUI.Struct.Thickness)">
            <summary>
            设置控件的外边距
            </summary>
            <param name = "control">目标控件</param>
            <param name = "margin">外边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Margin``1(``0,System.Single)">
            <summary>
            设置控件的外边距（统一值）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "margin">外边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Margin``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的外边距（水平和垂直）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "horizontal">水平外边距</param>
            <param name = "vertical">垂直外边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Padding``1(``0,GameUI.Struct.Thickness)">
            <summary>
            设置控件的内边距
            </summary>
            <param name = "control">目标控件</param>
            <param name = "padding">内边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Padding``1(``0,System.Single)">
            <summary>
            设置控件的内边距（统一值）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "padding">内边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Padding``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的内边距（水平和垂直）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "horizontal">水平内边距</param>
            <param name = "vertical">垂直内边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Padding``1(``0,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            设置控件的内边距（左、上、右、下）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "left">左内边距</param>
            <param name = "top">上内边距</param>
            <param name = "right">右内边距</param>
            <param name = "bottom">下内边距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignHorizontal``1(``0,GameUI.Enum.HorizontalAlignment)">
            <summary>
            设置控件的水平对齐方式
            </summary>
            <param name = "control">目标控件</param>
            <param name = "alignment">对齐方式</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignVertical``1(``0,GameUI.Enum.VerticalAlignment)">
            <summary>
            设置控件的垂直对齐方式
            </summary>
            <param name = "control">目标控件</param>
            <param name = "alignment">对齐方式</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Center``1(``0)">
            <summary>
            设置控件居中对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignLeft``1(``0)">
            <summary>
            设置控件左对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignRight``1(``0)">
            <summary>
            设置控件右对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignTop``1(``0)">
            <summary>
            设置控件顶部对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AlignBottom``1(``0)">
            <summary>
            设置控件底部对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.StretchHorizontal``1(``0)">
            <summary>
            设置控件水平拉伸
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.StretchVertical``1(``0)">
            <summary>
            设置控件垂直拉伸
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FillParent``1(``0)">
            <summary>
            设置控件填满父容器
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ContentAlignHorizontal``1(``0,GameUI.Enum.HorizontalContentAlignment)">
            <summary>
            设置控件子元素的水平对齐方式
            </summary>
            <param name = "control">目标控件</param>
            <param name = "alignment">对齐方式</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ContentAlignVertical``1(``0,GameUI.Enum.VerticalContentAlignment)">
            <summary>
            设置控件子元素的垂直对齐方式
            </summary>
            <param name = "control">目标控件</param>
            <param name = "alignment">对齐方式</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ContentCenter``1(``0)">
            <summary>
            设置控件子元素居中对齐
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.GrowRatio``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的增长比例（flex-grow）
            </summary>
            <remarks>
            当父容器有多余空间时，控件按此比例增长。对应CSS的flex-grow属性。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "widthGrow">宽度增长比例</param>
            <param name = "heightGrow">高度增长比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ShrinkRatio``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的收缩比例（flex-shrink）
            </summary>
            <remarks>
            当父容器空间不足时，控件按此比例收缩。对应CSS的flex-shrink属性。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "widthShrink">宽度收缩比例</param>
            <param name = "heightShrink">高度收缩比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.GrowWidth``1(``0,System.Single)">
            <summary>
            设置控件的水平增长比例
            </summary>
            <param name = "control">目标控件</param>
            <param name = "grow">增长比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.GrowHeight``1(``0,System.Single)">
            <summary>
            设置控件的垂直增长比例
            </summary>
            <param name = "control">目标控件</param>
            <param name = "grow">增长比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ShrinkWidth``1(``0,System.Single)">
            <summary>
            设置控件的水平收缩比例
            </summary>
            <param name = "control">目标控件</param>
            <param name = "shrink">收缩比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ShrinkHeight``1(``0,System.Single)">
            <summary>
            设置控件的垂直收缩比例
            </summary>
            <param name = "control">目标控件</param>
            <param name = "shrink">收缩比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Flex``1(``0,System.Single)">
            <summary>
            设置控件在Flex布局中占用比例权重
            </summary>
            <param name = "control">目标控件</param>
            <param name = "flex">Flex权重</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AspectRatio``1(``0,System.Single)">
            <summary>
            设置控件的宽高比
            </summary>
            <param name = "control">目标控件</param>
            <param name = "ratio">宽高比（宽度/高度）</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.VStack``1(``0,System.Single)">
            <summary>
            快速设置常用的垂直堆叠布局
            </summary>
            <param name = "control">目标控件</param>
            <param name = "spacing">子元素间距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.HStack``1(``0,System.Single)">
            <summary>
            快速设置常用的水平堆叠布局
            </summary>
            <param name = "control">目标控件</param>
            <param name = "spacing">子元素间距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlowVertical``1(``0)">
            <summary>
            设置控件为垂直流式布局
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlowHorizontal``1(``0)">
            <summary>
            设置控件为水平流式布局
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.Grid``1(``0,System.Int32,System.Int32,System.Single)">
            <summary>
            设置控件为网格布局
            </summary>
            <param name = "control">目标控件</param>
            <param name = "rows">行数</param>
            <param name = "columns">列数</param>
            <param name = "spacing">间距</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MinSize``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的最小尺寸（基础尺寸）
            </summary>
            <remarks>
            在这个UI库的Flexbox布局模型中，Width/Height实际上就是控件的最小尺寸。
            当设置了增长比例时，控件会从这个基础尺寸开始拉伸，不会小于这个值。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "minWidth">最小宽度（基础宽度）</param>
            <param name = "minHeight">最小高度（基础高度）</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MinWidth``1(``0,System.Single)">
            <summary>
            设置控件的最小宽度（基础宽度）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "minWidth">最小宽度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MinHeight``1(``0,System.Single)">
            <summary>
            设置控件的最小高度（基础高度）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "minHeight">最小高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MaxSize``1(``0,System.Single,System.Single)">
            <summary>
            设置控件的最大尺寸（通过禁用收缩实现）
            </summary>
            <remarks>
            这个UI库使用Flexbox模型，没有传统的MaxSize概念。
            此方法通过设置收缩比例为0来防止控件收缩，从而限制最大尺寸。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "maxWidth">最大宽度</param>
            <param name = "maxHeight">最大高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MaxWidth``1(``0,System.Single)">
            <summary>
            设置控件的最大宽度（通过禁用水平收缩实现）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "maxWidth">最大宽度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.MaxHeight``1(``0,System.Single)">
            <summary>
            设置控件的最大高度（通过禁用垂直收缩实现）
            </summary>
            <param name = "control">目标控件</param>
            <param name = "maxHeight">最大高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.SizeRange``1(``0,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            设置控件的尺寸范围（最小到最大）
            </summary>
            <remarks>
            在Flexbox模型中，通过设置基础尺寸和控制拉伸/收缩比例来实现尺寸约束。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "minWidth">最小宽度</param>
            <param name = "minHeight">最小高度</param>
            <param name = "maxWidth">最大宽度</param>
            <param name = "maxHeight">最大高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlexCSS``1(``0,System.Single,System.Single,System.Single)">
            <summary>
            使用CSS风格的flex参数设置控件
            </summary>
            <remarks>
            模拟CSS的 flex: grow shrink basis 语法，最直观的设置方式。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "grow">增长比例 (flex-grow)</param>
            <param name = "shrink">收缩比例 (flex-shrink)</param>
            <param name = "basis">基础尺寸 (flex-basis)</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlexAuto``1(``0)">
            <summary>
            设置控件为自动增长（等同于flex: 1）
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlexNone``1(``0)">
            <summary>
            设置控件为不伸缩（等同于flex: none）
            </summary>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FixedSize``1(``0,System.Single,System.Single)">
            <summary>
            设置控件为固定尺寸（不拉伸不收缩）
            </summary>
            <remarks>
            相当于CSS中的 flex: none，控件保持固定尺寸，不参与flex布局的拉伸和收缩。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "width">固定宽度</param>
            <param name = "height">固定高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FlexSize``1(``0,System.Single,System.Single,System.Single)">
            <summary>
            设置控件为基础尺寸，允许按比例拉伸
            </summary>
            <remarks>
            这是Flexbox布局的标准用法：设置基础尺寸，然后根据flex比例分配剩余空间。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "baseWidth">基础宽度</param>
            <param name = "baseHeight">基础高度</param>
            <param name = "flexGrow">拉伸比例（flex-grow）</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ResponsiveSize``1(``0,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            设置控件为响应式尺寸（可拉伸可收缩）
            </summary>
            <remarks>
            控件会根据容器大小动态调整，适合响应式布局。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "preferredWidth">首选宽度</param>
            <param name = "preferredHeight">首选高度</param>
            <param name = "flexGrow">拉伸比例</param>
            <param name = "flexShrink">收缩比例</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AutoWidthFixedHeight``1(``0,System.Single)">
            <summary>
            设置控件宽度为内容适应，高度固定
            </summary>
            <remarks>
            宽度自动适应内容，高度保持固定值。常用于按钮、标签等控件。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "height">固定高度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.FixedWidthAutoHeight``1(``0,System.Single)">
            <summary>
            设置控件高度为内容适应，宽度固定
            </summary>
            <remarks>
            高度自动适应内容，宽度保持固定值。常用于垂直文本显示。
            </remarks>
            <param name = "control">目标控件</param>
            <param name = "width">固定宽度</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.AutoSizeFixed``1(``0)">
            <summary>
            设置控件为内容自适应尺寸（不参与flex拉伸）
            </summary>
            <remarks>
            宽度和高度都根据内容自动调整，且不参与flex布局的拉伸和收缩。
            这是对已有AutoSize方法的增强版本。
            </remarks>
            <param name = "control">目标控件</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.CornerRadius``1(``0,System.Single)">
            <summary>
            为控件添加圆角
            </summary>
            <param name = "control">目标控件</param>
            <param name = "radius">圆角半径</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Control.Extensions.LayoutExtensions.ZIndex``1(``0,System.Int32)">
            <summary>
            设置控件的Z轴层级
            </summary>
            <param name = "control">目标控件</param>
            <param name = "zIndex">Z轴层级</param>
            <returns>控件本身，支持链式调用</returns>
        </member>
        <member name="T:GameUI.Control.GameEntryLoadingSystem">
            <summary>
            GameEntry Loading系统，在游戏初始化时自动显示Loading界面
            </summary>
            <remarks>
            这个系统实现了IGameClass接口，会在游戏启动时自动注册，
            并在适当的时机显示Loading界面，提供更好的用户体验。
            </remarks>
        </member>
        <member name="F:GameUI.Control.GameEntryLoadingSystem._startupLoading">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.GameEntryLoadingSystem._uiLoading">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.GameEntryLoadingSystem._isInitialized">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.GameEntryLoadingSystem.OnRegisterGameClass">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Control.GameEntryLoadingSystem.ShowLoading(System.String,System.Boolean,System.Boolean)">
            <summary>
            手动显示Loading界面（用于其他系统）
            </summary>
        </member>
        <member name="M:GameUI.Control.GameEntryLoadingSystem.HideAllLoading">
            <summary>
            隐藏所有Loading界面
            </summary>
        </member>
        <member name="T:GameUI.Control.LoadingUI">
            <summary>
            现代化的加载界面控件，提供进度显示、加载文本和动画效果
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._backgroundMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._loadingCard">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._loadingText">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._progressBar">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._progressText">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._cancelButton">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._isVisible">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._currentProgress">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._loadingMessage">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._showCancelButton">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._showProgress">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.LoadingUI._showProgressText">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.LoadingUI.Progress">
            <summary>
            当前加载进度 (0.0 - 1.0)
            </summary>
        </member>
        <member name="P:GameUI.Control.LoadingUI.LoadingMessage">
            <summary>
            加载文本消息
            </summary>
        </member>
        <member name="P:GameUI.Control.LoadingUI.ShowCancelButton">
            <summary>
            是否显示取消按钮
            </summary>
        </member>
        <member name="P:GameUI.Control.LoadingUI.ShowProgress">
            <summary>
            是否显示进度条
            </summary>
        </member>
        <member name="P:GameUI.Control.LoadingUI.ShowProgressText">
            <summary>
            是否显示进度文本
            </summary>
        </member>
        <member name="E:GameUI.Control.LoadingUI.CancelRequested">
            <summary>
            取消按钮点击事件
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.#ctor">
            <summary>
            创建LoadingUI实例
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.Show(System.String,System.Single)">
            <summary>
            显示加载界面
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.Hide">
            <summary>
            隐藏加载界面
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.UpdateProgress(System.Single,System.String)">
            <summary>
            更新加载进度
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.SetComplete(System.String)">
            <summary>
            设置加载完成状态
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.SetFailed(System.String)">
            <summary>
            设置加载失败状态
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.CreateSimple(System.String)">
            <summary>
            创建简单的加载界面
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.CreateWithProgress(System.String,System.Boolean)">
            <summary>
            创建带进度的加载界面
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUI.CreateFull(System.String)">
            <summary>
            创建全功能加载界面
            </summary>
        </member>
        <member name="T:GameUI.Control.LoadingUIExamples">
            <summary>
            LoadingUI使用示例，展示如何在GameEntry中集成Loading界面
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExamples.ShowGameStartupLoading">
            <summary>
            游戏启动时的资源加载示例
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExamples.ShowSceneTransitionLoading(System.String)">
            <summary>
            场景切换时的加载示例
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExamples.ShowNetworkConnectingLoading">
            <summary>
            网络连接时的等待示例
            </summary>
        </member>
        <member name="T:GameUI.Control.LoadingUIExtensions">
            <summary>
            LoadingUI的扩展方法，提供便捷的链式调用
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExtensions.Message(GameUI.Control.LoadingUI,System.String)">
            <summary>
            设置加载消息
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExtensions.Progress(GameUI.Control.LoadingUI,System.Single)">
            <summary>
            设置进度值
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExtensions.WithCancel(GameUI.Control.LoadingUI)">
            <summary>
            显示取消按钮
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExtensions.WithoutProgress(GameUI.Control.LoadingUI)">
            <summary>
            隐藏进度条
            </summary>
        </member>
        <member name="M:GameUI.Control.LoadingUIExtensions.Show(GameUI.Control.LoadingUI,System.String)">
            <summary>
            显示并返回自身
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.PointerEventArgs">
            <summary>
            Provides data for pointer-related events, such as mouse or touch input.
            </summary>
            <remarks>
            This event argument is used for pointer events, including mouse clicks, presses, releases, and finger touches.
            </remarks>
        </member>
        <member name="M:GameUI.Control.Struct.PointerEventArgs.#ctor(GameCore.Platform.SDL.PointerButtons)">
            <summary>
            Provides data for pointer-related events, such as mouse or touch input.
            </summary>
            <remarks>
            This event argument is used for pointer events, including mouse clicks, presses, releases, and finger touches.
            </remarks>
        </member>
        <member name="P:GameUI.Control.Struct.PointerEventArgs.PointerButtons">
            <summary>
            Gets the pointer buttons that triggered the event.
            For mouse events, this indicates which mouse buttons were pressed.
            For finger events, differentiate between fingers by using the touching ID.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.PointerCapturedMoveEventArgs">
            <summary>
            Provides data for pointer move events when the pointer is captured by a control.
            This event argument is used to indicate which pointer buttons are involved in the move,
            and which buttons are currently pressed on the control during the event.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.PointerCapturedMoveEventArgs.#ctor(GameCore.Platform.SDL.PointerButtons,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            Provides data for pointer move events when the pointer is captured by a control.
            This event argument is used to indicate which pointer buttons are involved in the move,
            and which buttons are currently pressed on the control during the event.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.PointerCapturedMoveEventArgs.ButtonsOnControl">
            <summary>
            Gets the set of pointer buttons that are currently pressed on the control at the time of the move event.
            This property is especially useful for handling multi-button or multi-finger interactions, such as resizing or complex gestures.
            If multiple pointer buttons are captured and moving on the control, each will trigger its own move event with the corresponding set of pressed buttons.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.DropEventArgs">
            <summary>
            Provides data for drag-and-drop events, indicating the target control of a drop operation.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.DropEventArgs.#ctor(GameUI.Control.Control)">
            <summary>
            Provides data for drag-and-drop events, indicating the target control of a drop operation.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.DropEventArgs.TargetControl">
            <summary>
            Gets the control that is the target of the drop operation.
            If null, the drop occurred on a blank area or on a control that does not support drop.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.ApplyControlTemplateEventArgs">
            <summary>
            Provides data for events related to applying a control template.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.ApplyControlTemplateEventArgs.#ctor(GameUI.Control.Control,GameData.IGameData{GameUI.Control.Data.GameDataControl})">
            <summary>
            Provides data for events related to applying a control template.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.ApplyControlTemplateEventArgs.Control">
            <summary>
            Gets the control to which the template is being applied.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.ApplyControlTemplateEventArgs.Template">
            <summary>
            Gets the template data being applied to the control.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.ApplyControlTemplatePhaseEventArgs">
            <summary>
            Provides data for events related to applying a control template at a specific phase.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.ApplyControlTemplatePhaseEventArgs.#ctor(GameUI.Control.Control,GameData.IGameData{GameUI.Control.Data.GameDataControl},System.Int32)">
            <summary>
            Provides data for events related to applying a control template at a specific phase.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.ApplyControlTemplatePhaseEventArgs.Phase">
            <summary>
            Gets the phase of the template application process.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.KeyboardAcceleratorEventArgs">
            <summary>
            Provides base data for keyboard accelerator events.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.KeyboardAcceleratorEventArgs.#ctor(GameUI.Control.Struct.KeyboardAccelerator)">
            <summary>
            Provides base data for keyboard accelerator events.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAcceleratorEventArgs.Accelerator">
            <summary>
            Gets the keyboard accelerator that triggered the event.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.KeyboardAcceleratorInvokedEventArgs">
            <summary>
            Provides data for events when a keyboard accelerator is invoked on a control.
            Only one control can invoke a keyboard accelerator at a time.
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.KeyboardAcceleratorInvokedEventArgs.#ctor(GameUI.Control.Control,GameUI.Control.Struct.KeyboardAccelerator)">
            <summary>
            Provides data for events when a keyboard accelerator is invoked on a control.
            Only one control can invoke a keyboard accelerator at a time.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAcceleratorInvokedEventArgs.Control">
            <summary>
            Gets the control that invoked the keyboard accelerator.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAcceleratorInvokedEventArgs.Handled">
            <summary>
            Gets or sets a value indicating whether the event has been handled.
            When set to true, it indicates that the event has been processed and no further action is required.
            The default invoked action of the control will not be executed. For example, if the control is a button, 
            the click action will not be triggered.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.KeyboardAccelerator">
             <summary>
             Represents a keyboard accelerator that defines a key and optional modifiers to trigger an action.
             </summary>
             <remarks>A keyboard accelerator is typically used to associate a specific key combination with a command or
             action within an application. The accelerator is considered active when <see cref = "P:GameUI.Control.Struct.KeyboardAccelerator.IsEnabled"/> is <see 
            langword="true"/>.</remarks>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAccelerator.IsEnabled">
            <summary>
            Gets or sets a value indicating whether this key combination is enabled.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAccelerator.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.KeyboardAccelerator.Modifiers">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.KeyboardAccelerator.Matches(GameUI.TriggerEvent.EventGameKeyDown)">
            <summary>
            
            </summary>
            <param name="down"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Control.Struct.VirtualizationCacheLengthUnit">
            <summary>
            VirtualizationCacheLengthUnit enum is used to indicate what kind of value the 
            VirtualizationCacheLength is holding.
            </summary>
        </member>
        <member name="F:GameUI.Control.Struct.VirtualizationCacheLengthUnit.Item">
            <summary>
            The value is expressed as an item.
            </summary>
        </member>
        <member name="F:GameUI.Control.Struct.VirtualizationCacheLengthUnit.Page">
            <summary>
            The value is expressed as a page full of item.
            </summary>
        </member>
        <member name="T:GameUI.Control.Struct.VirtualizationCacheLength">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.#ctor(System.Double)">
            <summary>
            Constructor, initializes the CacheBeforeViewport and the CacheAfterViewport to their sizes. Units are specified as a seperate VisualizationCacheLengthUnit property.
            </summary>
            <param name = "cacheBeforeAndAfterViewport">Value to be stored by this VirtualizationCacheLength 
            instance as the cacheBeforeViewport and cacheAfterViewport.</param>
            <exception cref = "T:System.ArgumentException">
            If <c>cacheBeforeAndAfterViewport</c> parameter is <c>double.NaN</c>
            or <c>cacheBeforeAndAfterViewport</c> parameter is <c>double.NegativeInfinity</c>
            or <c>cacheBeforeAndAfterViewport</c> parameter is <c>double.PositiveInfinity</c>.
            </exception>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.op_Equality(GameUI.Control.Struct.VirtualizationCacheLength,GameUI.Control.Struct.VirtualizationCacheLength)">
            <summary>
            Overloaded operator, compares 2 VirtualizationCacheLength's.
            </summary>
            <param name = "cl1">first VirtualizationCacheLength to compare.</param>
            <param name = "cl2">second VirtualizationCacheLength to compare.</param>
            <returns>true if specified VirtualizationCacheLengths have same value 
            and unit type.</returns>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.op_Inequality(GameUI.Control.Struct.VirtualizationCacheLength,GameUI.Control.Struct.VirtualizationCacheLength)">
            <summary>
            Overloaded operator, compares 2 VirtualizationCacheLength's.
            </summary>
            <param name = "cl1">first VirtualizationCacheLength to compare.</param>
            <param name = "cl2">second VirtualizationCacheLength to compare.</param>
            <returns>true if specified VirtualizationCacheLengths have either different value or 
            unit type.</returns>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.Equals(System.Object)">
            <summary>
            Compares this instance of VirtualizationCacheLength with another object.
            </summary>
            <param name = "obj">Reference to an object for comparison.</param>
            <returns><c>true</c>if this VirtualizationCacheLength instance has the same value 
            and unit type as oCompare.</returns>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.Equals(GameUI.Control.Struct.VirtualizationCacheLength)">
            <summary>
            Compares this instance of VirtualizationCacheLength with another instance.
            </summary>
            <param name = "cacheLength">Cache length instance to compare.</param>
            <returns><c>true</c>if this VirtualizationCacheLength instance has the same value 
            and unit type as cacheLength.</returns>
        </member>
        <member name="M:GameUI.Control.Struct.VirtualizationCacheLength.GetHashCode">
            <summary>
            <see cref = "M:System.Object.GetHashCode"/>
            </summary>
            <returns><see cref = "M:System.Object.GetHashCode"/></returns>
        </member>
        <member name="P:GameUI.Control.Struct.VirtualizationCacheLength.CacheBeforeViewport">
            <summary>
            Returns cacheBeforeViewport part of this VirtualizationCacheLength instance.
            </summary>
        </member>
        <member name="P:GameUI.Control.Struct.VirtualizationCacheLength.CacheAfterViewport">
            <summary>
            Returns cacheAfterViewport part of this VirtualizationCacheLength instance.
            </summary>
        </member>
        <member name="F:GameUI.Control.Struct.VirtualizationCacheLength._cacheBeforeViewport">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.Struct.VirtualizationCacheLength._cacheAfterViewport">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Control.UIRoot">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.UIRoot.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Control.UIRoot.children">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.UIRoot.Children">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.UIRoot.GameUI#Interface#INode#Children">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Control.UIRoot.DataContext">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.UIRoot.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Control.UIRoot.AddChild(GameUI.Control.Control)">
            <summary>
            
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Device.Enum.RayCastMode">
            <summary>
            定义射线检测的碰撞检测模式
            </summary>
            <remarks>
            <para><strong>⚠️ 重要提示：</strong></para>
            <para>不同的射线检测模式对游戏对象的模型数据有不同的要求。如果选择了需要特定包围盒数据的模式，
            但游戏对象的模型没有配置相应的包围盒，射线检测将会失败。</para>
            <para><strong>配置位置：</strong>模型的包围盒数据需要在相应的 GameDataModel 字段中配置，
            例如 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段用于配置简单包围圆柱体数据。</para>
            <para><strong>建议：</strong>对于大多数游戏，使用 <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> 模式是最安全的选择，
            因为它不需要特殊的模型配置。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Device.Enum.RayCastMode.AABB">
            <summary>
            轴对齐包围盒 (Axis-Aligned Bounding Box)
            </summary>
            <remarks>
            <para><strong>推荐模式</strong> - 适用于大多数游戏对象，不需要特殊的模型配置。</para>
            <para>使用游戏对象的轴对齐包围盒进行碰撞检测，兼容性最好。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Device.Enum.RayCastMode.OBB">
            <summary>
            有向包围盒 (Oriented Bounding Box)
            </summary>
            <remarks>
            <para><strong>需要模型配置</strong> - 需要在模型数据中设置相应的有向包围盒数据。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Device.Enum.RayCastMode.Triangle">
            <summary>
            三角形精确检测
            </summary>
            <remarks>
            <para>对模型的三角形网格进行精确的射线-三角形相交检测。</para>
            <para>精度最高但性能开销较大。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Device.Enum.RayCastMode.TriangleUV">
            <summary>
            三角形精确检测（包含UV坐标）
            </summary>
            <remarks>
            <para>与 <see cref = "F:GameUI.Device.Enum.RayCastMode.Triangle"/> 相似，但额外返回UV坐标信息。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder">
            <summary>
            简单包围圆柱体
            </summary>
            <remarks>
            <para><strong>需要模型配置</strong> - 需要在单位/表现的模型数据中预先设置 SimpleBoundingCylinder。</para>
            <para><strong>配置位置：</strong>在 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段中配置包围圆柱体数据。</para>
            <para><strong>⚠️ 注意：</strong>如果模型没有配置 SimpleBoundingCylinder 数据，射线检测将会失败！</para>
            </remarks>
        </member>
        <member name="T:GameUI.Device.Enum.PointerType">
            <summary>
            表示指针输入设备的类型
            </summary>
        </member>
        <member name="F:GameUI.Device.Enum.PointerType.Mouse">
            <summary>
            鼠标指针输入
            </summary>
        </member>
        <member name="F:GameUI.Device.Enum.PointerType.Touch">
            <summary>
            触摸指针输入
            </summary>
        </member>
        <member name="T:GameUI.Device.InputManager">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.InputManager.Primary">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnKeyDown">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnKeyUp">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnPointerButtonDown">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnPointerButtonUp">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnPointerButtonMove">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.InputManager.OnPointerWheelChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Device.InputManager.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.InputManager.PointerType">
            <summary>
            Gets the type of pointer input currently in use.
            </summary>
        </member>
        <member name="M:GameUI.Device.InputManager.OnRegisterGameClass">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Device.ScreenViewport">
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.Primary">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.Camera">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.WidthDP">
            <summary>
            In device pixels
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.HeightDP">
            <summary>
            In device pixels
            </summary>
        </member>
        <member name="E:GameUI.Device.ScreenViewport.OnSizeChanged">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.ScreenViewport.OnOrientationChanged">
            <summary>
            
            </summary>
        </member>
        <member name="E:GameUI.Device.ScreenViewport.OnDevicePixelRatioChanged">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.DesignResolutionLandscape">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.DesignResolutionPortrait">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.Size">
            <summary>
            Gets the size of the viewport in device-independent pixels (DIPs).
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.DesignResolution">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.DevicePixelRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.DisplayOrientations">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.SafeZonePadding">
            <summary>
            In device independent pixels
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport._SceneRendering">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.displayOrientations">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.SceneRendering">
            <summary>
            Gets or sets a value indicating whether scene rendering is enabled.
            </summary>
            <remarks>
            Setting this property to false will lock the scene render in the view, make it static.
            </remarks>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.GetPointerInputPosition(GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
            <param name="buttonIndex"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.GetPointerInputPositionDP(GameCore.Platform.SDL.PointerButtons)">
            <summary>
            In device pixels
            </summary>
            <param name = "button"></param>
            <returns></returns>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.gaussianBlurLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.GaussianBlurLevel">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.saturation">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.SaturationInput">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Device.ScreenViewport.multiply">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.ScreenViewport.MultiplyInput">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.OnRegisterGameClass">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.CreateDebugDraw">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastWorldPanel(GameUI.Struct.UIPosition,GameUI.Device.Enum.WorldPanel,System.Single)">
            <summary>
            Performs a raycast on a specified world panel at a given UI position and fixed axis value.
            </summary>
            <remarks>
            This method calculates the screen position in device-dependent pixels (DPI) based on the provided UI position
            and performs a raycast on the specified world panel (XY, XZ, or YZ). The raycast determines whether the panel
            is hit and, if so, returns the world position of the hit.
            </remarks>
            <param name = "position">The UI position, in logical pixels, where the raycast should be performed.</param>
            <param name = "panel">The world panel to raycast against. This can be one of the following: XY, XZ, or YZ.</param>
            <param name = "fixedAxisValue">
            The fixed axis value to use for the raycast. For example, if the panel is XY, this value represents the Z-coordinate.
            </param>
            <returns>
            A <see cref = "T:GameUI.Device.Struct.RaycastHitWorldPosition"/> object containing the result of the raycast. If the raycast hits the panel,
            the <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.Position"/> property will contain the world position of the hit, and
            <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.IsHit"/> will be <see langword="true"/>. Otherwise, <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.IsHit"/>
            will be <see langword="false"/>.
            </returns>
            <example>
            Example usage:
            <code>
            var viewport = new ScreenViewport();
            var uiPosition = new UIPosition { Left = 100, Top = 200 };
            var result = viewport.RaycastWorldPanel(uiPosition, WorldPanel.XY, 0);
            if (result.IsHit)
            {
                Game.Logger.LogInformation("Hit at world position: {0}", result.Position);
            }
            else
            {
                Game.Logger.LogInformation("No hit detected.");
            }
            </code>
            </example>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastWorldPanelDP(System.Single,System.Single,GameUI.Device.Enum.WorldPanel,System.Single)">
            <summary>
            Performs a raycast on a specified world panel at given screen coordinates and a fixed axis value.
            </summary>
            <remarks>
            This method directly operates on device-dependent coordinates to perform a raycast on the specified
            world panel (XY, XZ, or YZ). The raycast determines whether the panel is hit and, if so, returns the world position
            of the hit.
            </remarks>
            <param name = "x">The horizontal screen coordinate in device-dependent pixels.</param>
            <param name = "y">The vertical screen coordinate in device-dependent pixels.</param>
            <param name = "panel">The world panel to raycast against. This can be one of the following: XY, XZ, or YZ.</param>
            <param name = "fixedAxisValue">
            The fixed axis value to use for the raycast. For example, if the panel is XY, this value represents the Z-coordinate.
            </param>
            <returns>
            A <see cref = "T:GameUI.Device.Struct.RaycastHitWorldPosition"/> object containing the result of the raycast. If the raycast hits the panel,
            the <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.Position"/> property will contain the world position of the hit, and
            <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.IsHit"/> will be <see langword="true"/>. Otherwise, <see cref = "P:GameUI.Device.Struct.RaycastHitWorldPosition.IsHit"/>
            will be <see langword="false"/>.
            </returns>
            <example>
            Example usage:
            <code>
            var viewport = new ScreenViewport();
            var result = viewport.RaycastWorldPanelDP(150.0f, 300.0f, WorldPanel.XY, 0);
            if (result.IsHit)
            {
                Game.Logger.LogInformation("Hit at world position: {0}", result.Position);
            }
            else
            {
                Game.Logger.LogInformation("No hit detected.");
            }
            </code>
            </example>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastWorldToUI(GameCore.SceneSystem.ScenePoint)">
            <summary>
            Converts a world position to a corresponding UI position and determines if the conversion is valid.
            </summary>
            <remarks>The method maps a 3D world position to a 2D screen position and then to a UI position.</remarks>
            <param name = "scenePoint">The world position represented as a <see cref = "T:GameCore.SceneSystem.ScenePoint"/> to be converted to a UI
            position.</param>
            <returns>A <see cref = "T:GameUI.Device.Struct.RaycastHitUIPosition"/> object containing the converted UI position and a flag indicating whether
            the conversion was successful. If the conversion is invalid, the returned <see cref = "T:GameUI.Device.Struct.RaycastHitUIPosition"/>
            will have <see cref = "P:GameUI.Device.Struct.RaycastHitUIPosition.IsHit"/> set to <see langword="false"/>.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastWorldToScreenDP(GameCore.SceneSystem.ScenePoint)">
             <summary>
             Converts a world position to a screen position in device dependent pixels.
             </summary>
             <remarks>The method returns <see langword="false"/> for <c>success</c> if the world position cannot be
             mapped to a valid screen position.</remarks>
             <param name = "scenePoint">The world position, represented as a <see cref = "T:GameCore.SceneSystem.ScenePoint"/>, to be converted to screen
             coordinates.</param>
             <returns>A tuple containing the result of the conversion: <list type="bullet"> <item> <term><c>success</c></term>
             <description><see langword="true"/> if the conversion was successful; otherwise, <see 
            langword="false"/>.</description> </item> <item> <term><c>x</c></term> <description>The X-coordinate of the
             screen position.</description> </item> <item>
             <term><c>y</c></term> <description>The Y-coordinate of the screen position.</description> </item> </list></returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastWorldSpace(GameCore.SceneSystem.ScenePoint,System.Numerics.Vector3,System.Single,GameUI.Device.Enum.RayCastMode)">
            <summary>
            Performs a raycast in world space from a specified origin point in a given direction and length.
            </summary>
            <remarks>
            This method casts a ray in the world space starting from the specified origin point, extending in the given direction
            for the specified length. It determines whether the ray intersects with any objects in the scene and, if so, provides
            details about the hit, including the hit position and surface normal.
            </remarks>
            <param name = "origin">The starting point of the ray in world space, represented as a <see cref = "T:GameCore.SceneSystem.ScenePoint"/>.</param>
            <param name = "direction">The direction of the ray, represented as a <see cref = "T:System.Numerics.Vector3"/>.</param>
            <param name = "rayLength">The maximum length of the ray.</param>
            <param name = "mode">
            The mode of the raycast, determining the type of collision detection to use. The default is <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/>.
            </param>
            <returns>
            A <see cref = "T:GameUI.Device.Struct.RaycastHitWorld"/> object containing the result of the raycast. If the ray hits an object, the
            <see cref = "P:GameUI.Device.Struct.RaycastHitWorld.IsHit"/> property will be <see langword="true"/>, and the <see cref = "P:GameUI.Device.Struct.RaycastHitWorld.Position"/>
            and <see cref = "P:GameUI.Device.Struct.RaycastHitWorld.Normal"/> properties will contain the hit position and surface normal, respectively.
            If no object is hit, <see cref = "P:GameUI.Device.Struct.RaycastHitWorld.IsHit"/> will be <see langword="false"/>.
            </returns>
            <example>
            Example usage:
            <code>
            var viewport = new ScreenViewport();
            var origin = new ScenePoint(0, 0, new Scene());
            var direction = new System.Numerics.Vector3(1, 0, 0);
            float rayLength = 100f;
            var result = viewport.RaycastWorldSpace(origin, direction, rayLength);
            if (result.IsHit)
            {
                Game.Logger.LogInformation("Hit at world position: {0}, Normal: {1}", result.Point, result.Normal);
            }
            else
            {
                Game.Logger.LogInformation("No hit detected.");
            }
            </code>
            </example>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastTerrain(GameUI.Struct.UIPosition)">
            <summary>
            Performs a raycast on the terrain at the specified UI position.
            </summary>
            <remarks>The input position is automatically adjusted for the device's pixel density using the device
            pixel ratio.</remarks>
            <param name = "position">The position on the UI, specified in logical pixels, where the raycast should be performed.</param>
            <returns>A <see cref = "T:GameUI.Device.Struct.RaycastHitWorld"/> object containing the result of the raycast,  including information about the
            hit location and any intersected terrain features.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastTerrainOrWorldPanelXY(GameUI.Struct.UIPosition,System.Single)">
            <summary>
            Performs a raycast on the terrain or a world panel in the XY plane based on the specified UI position.
            </summary>
            <remarks>This method first attempts to perform a raycast against the terrain. If the terrain is hit,
            the resulting position is returned. If the terrain is not hit, the method performs a raycast against the world
            panel in the XY plane using the specified Z-axis value.</remarks>
            <param name = "uiPosition">The UI position, in screen coordinates, used to determine the raycast origin.</param>
            <param name = "zAxisValue">The Z-axis value to use when raycasting against the world panel. Defaults to <see langword="0f"/>.</param>
            <returns>A <see cref = "T:GameUI.Device.Struct.RaycastHitWorldPosition"/> object containing the result of the raycast. If the raycast hits the
            terrain, the result includes the hit position. Otherwise, the result of the world panel raycast is returned.
            </returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastTerrainDP(System.Single,System.Single)">
            <summary>
            Retrieves the screen point for raycasting to terrain.
            </summary>
            <param name = "x">The x coordinate for the raycast.</param>
            <param name = "y">The y coordinate for the raycast.</param>
            <returns>A RaycastHitTerrain object containing the hit information.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastActor(GameUI.Struct.UIPosition,GameUI.Device.Enum.RayCastMode)">
            <summary>
            Retrieves actors at specified UIPosition using a raycast, optionally filtering results based on a
            condition.
            </summary>
            <remarks>
            <para>The <paramref name = "position"/> is automatically scaled by the device pixel ratio to ensure
            accurate hit detection.</para>
            <para><strong>⚠️ 射线检测模式选择重要提示：</strong></para>
            <para>如果使用 <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/> 或其他需要特定包围盒数据的模式，
            请确保目标游戏对象的模型数据中已配置相应的包围盒。如果没有配置，射线检测将会失败。</para>
            <para><strong>配置位置：</strong>SimpleBoundingCylinder 数据需要在 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段中配置。</para>
            <para><strong>建议：</strong>对于大多数游戏项目，使用默认的 <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> 模式，
            因为它具有最好的兼容性且不需要特殊的模型配置。</para>
            </remarks>
            <param name = "position">The UI position, in device-independent pixels (DIPs), to perform the raycast operation.</param>
            <param name = "mode">The mode of the raycast operation, determining the type of bounding box used for hit detection. 
            The default is <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/>, which provides the best compatibility for most game objects.</param>
            <returns>An enumerable collection of <see cref = "T:GameCore.Interface.IActor"/> instances that are hit by the raycast at the specified position.
            The collection will be empty if no actors are hit.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastActorDP(System.Single,System.Single,GameUI.Device.Enum.RayCastMode)">
            <summary>
            Performs a raycast at specified screen coordinates and returns a collection of actors intersected by the ray, only works for model or particle actor that is not transient, and not destroyed or garbage collected. Entities and units are also included in the result.
            </summary>
            <remarks>
            <para><strong>⚠️ 射线检测模式选择重要提示：</strong></para>
            <para>某些射线检测模式（如 <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/>）需要游戏对象的模型数据中
            预先配置相应的包围盒数据。如果模型没有配置这些数据，射线检测将会失败。</para>
            <para><strong>配置位置：</strong>SimpleBoundingCylinder 数据需要在 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段中配置。</para>
            <para><strong>建议：</strong>对于大多数游戏项目，使用 <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> 模式
            以获得最佳兼容性。</para>
            </remarks>
            <param name = "x">Specifies the horizontal device-dependent coordinate for the raycast.</param>
            <param name = "y">Specifies the vertical device-dependent coordinate for the raycast.</param>
            <param name = "mode">Determines the method used for collision detection during the raycast. 
            <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> is recommended for best compatibility.</param>
            <returns>Yields a collection of actors that intersect with the raycast.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastEntities(GameUI.Struct.UIPosition,System.Func{GameCore.EntitySystem.Entity,System.Boolean},GameUI.Device.Enum.RayCastMode)">
            <summary>
            Retrieves entities at specified UIPosition using a raycast, optionally filtering results based on a condition.
            </summary>
            <remarks>
            <para><strong>⚠️ 重要注意事项：</strong></para>
            <para>默认使用 <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/> 模式，但这需要实体/单位的模型数据中
            预先配置 SimpleBoundingCylinder 数据。如果模型没有配置这些数据，射线检测将会失败！</para>
            <para><strong>配置位置：</strong>SimpleBoundingCylinder 数据需要在 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段中配置。</para>
            <para><strong>建议：</strong>如果你的游戏项目中的单位模型没有配置 SimpleBoundingCylinder 数据，
            请改用 <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> 模式以确保射线检测正常工作。</para>
            </remarks>
            <param name = "position">
            Specifies the screen coordinates for the raycast, which are in device-independent pixels (DIPs).
            </param>
            <param name = "filter">
            An optional function to determine which entities to include based on a condition.
            </param>
            <param name = "mode">Defines the method of raycasting to be used for detecting entities. 
            Note: The default <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/> requires model data configuration.
            Consider using <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> for better compatibility.</param>
            <returns>An enumerable collection of entities that meet the specified criteria.</returns>
        </member>
        <member name="M:GameUI.Device.ScreenViewport.RaycastEntitiesDP(System.Single,System.Single,System.Func{GameCore.EntitySystem.Entity,System.Boolean},GameUI.Device.Enum.RayCastMode)">
            <summary>
            Retrieves entities at specified screen coordinates using a raycast, optionally filtering results based on a
            condition.
            </summary>
            <remarks>
            <para><strong>⚠️ 重要注意事项：</strong></para>
            <para>默认使用 <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/> 模式，但这需要实体/单位的模型数据中
            预先配置 SimpleBoundingCylinder 数据。如果模型没有配置这些数据，射线检测将会失败！</para>
            <para><strong>配置位置：</strong>SimpleBoundingCylinder 数据需要在 <see cref = "!:GameDataModel.SimpleBoundingCylinder"/> 字段中配置。</para>
            <para><strong>建议：</strong>如果你的游戏项目中的单位模型没有配置 SimpleBoundingCylinder 数据，
            请改用 <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> 模式以确保射线检测正常工作。</para>
            </remarks>
            <param name = "x">Specifies the horizontal device-dependent screen coordinate for the raycast.</param>
            <param name = "y">Specifies the vertical device-dependent screen coordinate for the raycast.</param>
            <param name = "filter">An optional function to determine which entities to include based on a condition.</param>
            <param name = "mode">Defines the method of raycasting to be used for detecting entities. 
            Note: The default <see cref = "F:GameUI.Device.Enum.RayCastMode.SimpleBoundingCylinder"/> requires model data configuration.
            Consider using <see cref = "F:GameUI.Device.Enum.RayCastMode.AABB"/> for better compatibility.</param>
            <returns>An enumerable collection of entities that meet the specified criteria.</returns>
        </member>
        <member name="T:GameUI.Device.Struct.RaycastHitUIPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitUIPosition.UIPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitUIPosition.IsHit">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Device.Struct.RaycastHitWorld">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitWorld.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitWorld.Normal">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitWorld.IsHit">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Device.Struct.RaycastHitWorldPosition">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitWorldPosition.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.Struct.RaycastHitWorldPosition.IsHit">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Device.DeviceInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.DeviceInfo.Platform">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.DeviceInfo.PrimaryViewport">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Device.DeviceInfo.PrimaryInputManager">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Enum.Orientation.Vertical">
            <summary>
            Represents the vertical orientation or alignment. It is often used in layout and design contexts.
            </summary>
        </member>
        <member name="F:GameUI.Enum.Orientation.Horizontal">
            <summary>
            Defines the horizontal alignment of an element. It determines how the element is positioned along the horizontal
            axis.
            </summary>
        </member>
        <member name="F:GameUI.Enum.UIPositionType.Relative">
            <summary>
            相对定位，基于自身排版后的位置进行偏移。
            </summary>
        </member>
        <member name="F:GameUI.Enum.UIPositionType.Absolute">
            <summary>
            绝对定位，基于父容器左上角的位置进行偏移。
            </summary>
        </member>
        <member name="T:GameUI.Examples.DrawPathExample">
            <summary>
            DrawPath 方法使用示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.#ctor(GameUI.Control.Primitive.Canvas)">
            <summary>
            DrawPath 方法使用示例
            </summary>
        </member>
        <member name="F:GameUI.Examples.DrawPathExample.canvas">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawBasicShapes">
            <summary>
            绘制基本形状示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawComplexPath">
            <summary>
            绘制复杂路径示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawBezierCurves">
            <summary>
            绘制贝塞尔曲线示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawCompositePath">
            <summary>
            绘制组合路径示例（多个子路径）
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawPathWithArcs">
            <summary>
            绘制带圆弧的路径示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.DrawPathExample.DrawTransformedPath">
            <summary>
            使用路径变换示例
            </summary>
        </member>
        <member name="T:GameUI.Examples.JoystickExamples">
            <summary>
            摇杆控件使用示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.JoystickExamples.CreateNormalJoystick">
            <summary>
            创建普通摇杆示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.JoystickExamples.CreateFloatJoystick">
            <summary>
            创建浮动摇杆示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.JoystickExamples.CreateDynamicJoystick">
            <summary>
            创建动态摇杆示例
            </summary>
        </member>
        <member name="M:GameUI.Examples.JoystickExamples.CreateCustomImageJoystick">
            <summary>
            创建带有自定义图像的摇杆
            </summary>
        </member>
        <member name="M:GameUI.Examples.JoystickExamples.DemonstrateRuntimeConfiguration">
            <summary>
            演示如何在运行时调整摇杆属性
            </summary>
        </member>
        <member name="T:GameUI.Extensions.ColorExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.ToHex(System.Drawing.Color)">
            <summary>
            
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.ToHex(System.Drawing.Color,System.Byte)">
            <summary>
            
            </summary>
            <param name="color"></param>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.ToRgbaHex(System.Drawing.Color)">
            <summary>
            
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.FromHex(System.String)">
            <summary>
            
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.FromRgbaHex(System.String)">
            <summary>
            
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.ColorExtensions.FromHex(System.String,System.Byte)">
            <summary>
            
            </summary>
            <param name="hex"></param>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Extensions.PointFExtension">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Extensions.PointFExtension.Equals(System.Drawing.PointF,System.Object,System.Single)">
            <summary>
            
            </summary>
            <param name="pointF"></param>
            <param name="o"></param>
            <param name="epsilon"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.PointFExtension.Offset(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="pointF"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.PointFExtension.Scale(System.Drawing.PointF,System.Single)">
            <summary>
            
            </summary>
            <param name="pointF"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Extensions.PointFExtension.Scale(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="pointF"></param>
            <param name="scaleX"></param>
            <param name="scaleY"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Graphics.ArcFlattener">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._cx">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._cy">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._diameter">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._radius">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._fx">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._fy">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._sweep">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._startAngle">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.ArcFlattener._startPoint">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Graphics.ArcFlattener.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Graphics.ArcFlattener.CreateFlattenedPath(System.Single)">
            <summary>
            
            </summary>
            <param name="flatness"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Graphics.BoxGradientPaint">
            <summary>
            表示在矩形区域内创建渐变的盒式渐变画笔，支持可选的圆角和羽化效果
            </summary>
            <remarks>
            <para>盒式渐变适用于创建柔和的矩形背景、按钮效果和边框面板。</para>
            <para>渐变从指定矩形中心的起始颜色过渡到边缘的结束颜色。</para>
            <para>当半径为0时，创建尖锐的矩形渐变。当半径>0时，创建圆角矩形渐变。</para>
            </remarks>
            <param name = "rectangle">渐变效果的矩形区域</param>
            <param name = "cornerRadius">圆角矩形效果的圆角半径。使用0表示尖角</param>
            <param name = "feather">控制渐变过渡柔和度的羽化距离</param>
            <param name = "startColor">渐变中心的颜色</param>
            <param name = "endColor">渐变边缘的颜色</param>
        </member>
        <member name="M:GameUI.Graphics.BoxGradientPaint.#ctor(System.Drawing.RectangleF,System.Single,System.Single,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            表示在矩形区域内创建渐变的盒式渐变画笔，支持可选的圆角和羽化效果
            </summary>
            <remarks>
            <para>盒式渐变适用于创建柔和的矩形背景、按钮效果和边框面板。</para>
            <para>渐变从指定矩形中心的起始颜色过渡到边缘的结束颜色。</para>
            <para>当半径为0时，创建尖锐的矩形渐变。当半径>0时，创建圆角矩形渐变。</para>
            </remarks>
            <param name = "rectangle">渐变效果的矩形区域</param>
            <param name = "cornerRadius">圆角矩形效果的圆角半径。使用0表示尖角</param>
            <param name = "feather">控制渐变过渡柔和度的羽化距离</param>
            <param name = "startColor">渐变中心的颜色</param>
            <param name = "endColor">渐变边缘的颜色</param>
        </member>
        <member name="P:GameUI.Graphics.BoxGradientPaint.StartColor">
            <summary>
            获取渐变中心的颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.BoxGradientPaint.EndColor">
            <summary>
            获取渐变边缘的颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.BoxGradientPaint.Rectangle">
            <summary>
            获取渐变效果的矩形区域
            </summary>
        </member>
        <member name="P:GameUI.Graphics.BoxGradientPaint.CornerRadius">
            <summary>
            获取圆角矩形效果的圆角半径
            </summary>
            <value>圆角半径值。使用0表示尖角，正值表示圆角。</value>
        </member>
        <member name="P:GameUI.Graphics.BoxGradientPaint.Feather">
            <summary>
            获取控制渐变过渡柔和度的羽化距离
            </summary>
            <value>羽化距离。值越大，过渡越柔和。</value>
        </member>
        <member name="M:GameUI.Graphics.BoxGradientPaint.CreateUnmanagedGradient">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Graphics.Enum.LineCap">
            <summary>
            定义线条端点的样式
            </summary>
            <remarks>
            <para>线条端点样式决定了线条两端的形状外观。</para>
            <para>不同的端点样式适用于不同的设计需求：</para>
            <list type="bullet">
            <item><description>Butt: 适用于精确的技术图形和简洁的线条</description></item>
            <item><description>Round: 适用于柔和的设计和艺术图形</description></item>
            <item><description>Square: 适用于需要加强端点视觉重量的场合</description></item>
            </list>
            </remarks>
            <example>
            <code>
            // 设置圆形端点
            canvas.LineCap = LineCap.Round;
            canvas.StrokeSize = 8f;
            canvas.DrawLine(10, 10, 100, 10); // 绘制带圆形端点的粗线
            
            // 设置方形端点
            canvas.LineCap = LineCap.Square;
            canvas.DrawLine(10, 20, 100, 20); // 端点会向外延伸
            </code>
            </example>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineCap.Butt">
            <summary>
            平头端点 - 线条在端点处平齐截止
            </summary>
            <remarks>
            <para>线条在端点处直接截止，不向外延伸。</para>
            <para>这是最简洁的端点样式，线条长度等于指定的长度。</para>
            <para>适用于技术绘图和需要精确控制线条长度的场合。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineCap.Round">
            <summary>
            圆形端点 - 线条端点为半圆形
            </summary>
            <remarks>
            <para>在线条两端添加半圆形的端点，半圆的直径等于线条宽度。</para>
            <para>创建柔和、圆润的视觉效果，线条总长度会增加一个线条宽度。</para>
            <para>适用于艺术设计和需要柔和外观的界面元素。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineCap.Square">
            <summary>
            方形端点 - 线条端点为方形，向外延伸线条宽度的一半
            </summary>
            <remarks>
            <para>在线条两端添加方形的端点，向外延伸线条宽度的一半。</para>
            <para>增强端点的视觉重量，线条总长度会增加一个线条宽度。</para>
            <para>适用于需要强调端点或创建厚重感的设计。</para>
            </remarks>
        </member>
        <member name="T:GameUI.Graphics.Enum.LineJoin">
            <summary>
            定义线条连接处的样式
            </summary>
            <remarks>
            <para>线条连接样式决定了两条线段相交时连接点的外观。</para>
            <para>不同的连接样式适用于不同的设计需求：</para>
            <list type="bullet">
            <item><description>Miter: 适用于需要锐利边角的技术图形和建筑设计</description></item>
            <item><description>Round: 适用于柔和的艺术设计和有机形状</description></item>
            <item><description>Bevel: 适用于需要控制尖角长度或创建现代简洁效果的场合</description></item>
            </list>
            <para>连接样式与MiterLimit属性配合使用，可以精确控制连接效果。</para>
            </remarks>
            <example>
            <code>
            // 设置圆形连接
            canvas.LineJoin = LineJoin.Round;
            canvas.StrokeSize = 8f;
            canvas.DrawTriangle(50, 10, 10, 90, 90, 90); // 绘制带圆角连接的三角形
            
            // 设置斜接连接并限制斜接长度
            canvas.LineJoin = LineJoin.Miter;
            canvas.MiterLimit = 5.0f;
            // 绘制尖角形状，过尖的角会自动变为斜切
            </code>
            </example>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineJoin.Miter">
            <summary>
            斜接连接 - 线条在连接处以尖角相接
            </summary>
            <remarks>
            <para>通过延伸线条的外边缘直到它们相交来创建尖锐的角。</para>
            <para>当两条线段的夹角很小时，斜接可能会变得很长。</para>
            <para>可以通过MiterLimit属性控制最大斜接长度，超过限制时自动切换为斜切连接。</para>
            <para>适用于技术绘图、建筑图纸和需要精确角度的场合。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineJoin.Round">
            <summary>
            圆形连接 - 线条在连接处以圆弧相接
            </summary>
            <remarks>
            <para>使用圆弧来连接两条线段的外边缘，创建平滑的圆角效果。</para>
            <para>圆弧的半径等于线条宽度的一半。</para>
            <para>消除了尖锐的角，创造柔和、友好的视觉效果。</para>
            <para>适用于艺术设计、UI界面元素和需要柔和外观的图形。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.LineJoin.Bevel">
            <summary>
            斜切连接 - 线条在连接处以平角相接
            </summary>
            <remarks>
            <para>通过在连接点处切断线条的外边缘来创建平角连接。</para>
            <para>避免了过长的尖角，同时保持了角的存在感。</para>
            <para>连接长度受到控制，适用于各种角度而不会产生过度延伸。</para>
            <para>适用于现代设计、简洁的图标和需要控制角度大小的场合。</para>
            </remarks>
        </member>
        <member name="T:GameUI.Graphics.Enum.PaintApply">
            <summary>
            定义画笔的应用方式
            </summary>
        </member>
        <member name="F:GameUI.Graphics.Enum.PaintApply.Fill">
            <summary>
            填充 - 将画笔应用于形状的内部填充
            </summary>
        </member>
        <member name="F:GameUI.Graphics.Enum.PaintApply.Stroke">
            <summary>
            描边 - 将画笔应用于形状的轮廓线条
            </summary>
        </member>
        <member name="T:GameUI.Graphics.Enum.PathOperation">
            <summary>
            定义路径中可以执行的各种操作类型
            </summary>
            <remarks>
            <para>路径操作枚举定义了构建复杂路径时可以使用的所有基本操作。</para>
            <para>这些操作可以组合使用来创建各种复杂的几何形状和曲线。</para>
            <para>路径通常以Move操作开始，然后通过各种绘制操作来构建形状，最后可选择性地使用Close操作闭合路径。</para>
            </remarks>
            <example>
            <code>
            var path = new PathF();
            // Move操作：移动到起点
            path.MoveTo(10, 10);
            // Line操作：绘制直线
            path.LineTo(100, 10);
            // AddCircle操作：添加圆形
            path.AddCircle(new PointF(50, 50), 20);
            // Close操作：闭合路径
            path.Close();
            </code>
            </example>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Move">
            <summary>
            移动操作
            </summary>
            <remarks>
            <para>将当前绘制位置移动到指定点，不绘制任何内容。</para>
            <para>这是开始新路径或新子路径的标准方式。</para>
            <para>通常是路径的第一个操作，也可以用于创建不连续的路径段。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Line">
            <summary>
            直线操作
            </summary>
            <remarks>
            <para>从当前位置绘制一条直线到指定点。</para>
            <para>绘制完成后，当前位置更新为直线的终点。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Quad">
            <summary>
            二次贝塞尔曲线操作
            </summary>
            <remarks>
            <para>从当前位置绘制一条二次贝塞尔曲线到指定点。</para>
            <para>二次贝塞尔曲线使用一个控制点来定义曲线的形状。</para>
            <para>适用于创建简单的平滑曲线。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Cubic">
            <summary>
            三次贝塞尔曲线操作
            </summary>
            <remarks>
            <para>从当前位置绘制一条三次贝塞尔曲线到指定点。</para>
            <para>三次贝塞尔曲线使用两个控制点来提供更精细的曲线控制。</para>
            <para>适用于创建复杂的平滑曲线和专业的图形设计。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Arc">
            <summary>
            圆弧操作
            </summary>
            <remarks>
            <para>绘制一个圆弧，连接当前位置和指定点。</para>
            <para>圆弧的形状由两个控制点和半径参数定义。</para>
            <para>适用于创建圆滑的转角和弧形连接。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddRectangle">
            <summary>
            添加矩形操作
            </summary>
            <remarks>
            <para>在路径中添加一个矩形子路径。</para>
            <para>矩形作为一个独立的闭合子路径添加到当前路径中。</para>
            <para>不影响当前绘制位置。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddRoundedRectangle">
            <summary>
            添加圆角矩形操作
            </summary>
            <remarks>
            <para>在路径中添加一个带圆角的矩形子路径。</para>
            <para>圆角矩形作为一个独立的闭合子路径添加到当前路径中。</para>
            <para>圆角半径可以自定义，适用于现代UI设计。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddCircle">
            <summary>
            添加圆形操作
            </summary>
            <remarks>
            <para>在路径中添加一个圆形子路径。</para>
            <para>圆形作为一个独立的闭合子路径添加到当前路径中。</para>
            <para>不影响当前绘制位置。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddEllipse">
            <summary>
            添加椭圆操作
            </summary>
            <remarks>
            <para>在路径中添加一个椭圆子路径。</para>
            <para>椭圆作为一个独立的闭合子路径添加到当前路径中。</para>
            <para>可以指定不同的X轴和Y轴半径来创建各种椭圆形状。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddCircleArc">
            <summary>
            添加圆弧操作
            </summary>
            <remarks>
            <para>在路径中添加一个圆弧子路径。</para>
            <para>可以指定起始角度、结束角度和旋转方向来创建精确的圆弧。</para>
            <para>适用于创建扇形、弧形装饰和部分圆形。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.AddEllipseArc">
            <summary>
            添加椭圆弧操作
            </summary>
            <remarks>
            <para>在路径中添加一个椭圆弧子路径。</para>
            <para>可以指定不同的X轴和Y轴半径，以及起始角度、结束角度和旋转方向。</para>
            <para>提供最大的灵活性来创建各种弧形形状。</para>
            </remarks>
        </member>
        <member name="F:GameUI.Graphics.Enum.PathOperation.Close">
            <summary>
            闭合路径操作
            </summary>
            <remarks>
            <para>通过绘制一条从当前位置到路径起点的直线来闭合当前路径。</para>
            <para>闭合路径对于填充操作很重要，确保形状完全封闭。</para>
            <para>闭合后，当前位置回到路径的起点。</para>
            </remarks>
        </member>
        <member name="T:GameUI.Graphics.GeometryUtil">
            <summary>
            提供几何计算和图形变换的实用工具方法
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.Epsilon">
            <summary>
            用于浮点数比较的精度常量
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.DegreesToRadiansConstant">
            <summary>
            角度转弧度的转换常量 (π/180)
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.RadiansToDegreesConstant">
            <summary>
            弧度转角度的转换常量 (180/π)
            </summary>
        </member>
        <member name="T:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians">
            <summary>
            一些常用角度的弧度值常量，避免重复计算
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees0">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees30">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees45">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees60">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees90">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees120">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees135">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees180">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees270">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.GeometryUtil.CommonAnglesInRadians.Degrees360">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetDistance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            计算两点之间的距离
            </summary>
            <param name = "x1">第一个点的X坐标</param>
            <param name = "y1">第一个点的Y坐标</param>
            <param name = "x2">第二个点的X坐标</param>
            <param name = "y2">第二个点的Y坐标</param>
            <returns>两点之间的欧几里得距离</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetAngleAsDegrees(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            计算从第一个点到第二个点的角度（以度为单位）
            </summary>
            <param name = "x1">第一个点的X坐标</param>
            <param name = "y1">第一个点的Y坐标</param>
            <param name = "x2">第二个点的X坐标</param>
            <param name = "y2">第二个点的Y坐标</param>
            <returns>角度值（度）</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.DegreesToRadians(System.Single)">
            <summary>
            将角度从度转换为弧度
            </summary>
            <param name = "angle">以度为单位的角度</param>
            <returns>以弧度为单位的角度</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.DegreesToRadians(System.Double)">
            <summary>
            将角度从度转换为弧度（双精度版本）
            </summary>
            <param name = "angle">以度为单位的角度</param>
            <returns>以弧度为单位的角度</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.RadiansToDegrees(System.Single)">
            <summary>
            将角度从弧度转换为度
            </summary>
            <param name = "angle">以弧度为单位的角度</param>
            <returns>以度为单位的角度</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.RadiansToDegrees(System.Double)">
            <summary>
            将角度从弧度转换为度（双精度版本）
            </summary>
            <param name = "angle">以弧度为单位的角度</param>
            <returns>以度为单位的角度</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.RotatePoint(System.Drawing.PointF,System.Single)">
            <summary>
            围绕原点旋转点
            </summary>
            <param name = "point">要旋转的点</param>
            <param name = "angle">旋转角度（度）</param>
            <returns>旋转后的点</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.RotatePoint(System.Drawing.PointF,System.Drawing.PointF,System.Single)">
            <summary>
            围绕指定中心点旋转点
            </summary>
            <param name = "center">旋转中心点</param>
            <param name = "point">要旋转的点</param>
            <param name = "angle">旋转角度（度）</param>
            <returns>旋转后的点</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetSweep(System.Single,System.Single,System.Boolean)">
            <summary>
            计算弧形扫描角度
            </summary>
            <param name = "angle1">起始角度</param>
            <param name = "angle2">结束角度</param>
            <param name = "clockwise">是否顺时针方向</param>
            <returns>扫描角度</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.PolarToPoint(System.Single,System.Single,System.Single)">
            <summary>
            将极坐标转换为笛卡尔坐标点
            </summary>
            <param name = "angleInRadians">角度（弧度）</param>
            <param name = "fx">X轴缩放因子</param>
            <param name = "fy">Y轴缩放因子</param>
            <returns>转换后的点</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.EllipseAngleToPoint(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            获取椭圆上对应于给定角度的点
            </summary>
            <param name = "x">边界矩形的X位置</param>
            <param name = "y">边界矩形的Y位置</param>
            <param name = "width">边界矩形的宽度</param>
            <param name = "height">边界矩形的高度</param>
            <param name = "angleInDegrees">角度（度）</param>
            <returns>椭圆上的点</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetOppositePoint(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            获取相对于枢轴点的对称点
            </summary>
            <param name = "pivot">枢轴点</param>
            <param name = "oppositePoint">要获取对称点的点</param>
            <returns>对称点</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.IsLineIntersectingLine(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            检查两条线段是否相交
            </summary>
            <param name = "x0">第一条线段起点的X坐标</param>
            <param name = "y0">第一条线段起点的Y坐标</param>
            <param name = "x1">第一条线段终点的X坐标</param>
            <param name = "y1">第一条线段终点的Y坐标</param>
            <param name = "x2">第二条线段起点的X坐标</param>
            <param name = "y2">第二条线段起点的Y坐标</param>
            <param name = "x3">第二条线段终点的X坐标</param>
            <param name = "y3">第二条线段终点的Y坐标</param>
            <returns>如果两条线段相交则返回true</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetFactor(System.Single,System.Single,System.Single)">
            <summary>
            计算在给定范围内某个值的比例因子
            </summary>
            <param name = "aMin">最小值</param>
            <param name = "aMax">最大值</param>
            <param name = "aValue">当前值</param>
            <returns>比例因子（0.0到1.0之间）</returns>
        </member>
        <member name="M:GameUI.Graphics.GeometryUtil.GetLinearValue(System.Single,System.Single,System.Single)">
            <summary>
            根据比例因子在给定范围内计算线性值
            </summary>
            <param name = "aMin">最小值</param>
            <param name = "aMax">最大值</param>
            <param name = "aFactor">比例因子（0.0到1.0之间）</param>
            <returns>计算得出的线性值</returns>
        </member>
        <member name="T:GameUI.Graphics.GradientPaint">
            <summary>
            表示在多种颜色之间过渡的渐变画笔的抽象基类
            </summary>
            <remarks>
            <para>渐变画笔创建平滑的颜色过渡，用于高级视觉效果。</para>
            <para>派生类包括<see cref = "T:GameUI.Graphics.LinearGradientPaint"/>、<see cref = "T:GameUI.Graphics.RadialGradientPaint"/>和<see cref = "T:GameUI.Graphics.BoxGradientPaint"/>。</para>
            </remarks>
        </member>
        <member name="P:GameUI.Graphics.GradientPaint.StartColor">
            <summary>
            获取渐变的起始颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.GradientPaint.EndColor">
            <summary>
            获取渐变的结束颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.GradientPaint.UnmanagedGradient">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Graphics.GradientPaint.CreateUnmanagedGradient">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Graphics.GradientPaint.Apply(GameUI.Control.Primitive.Canvas,GameUI.Graphics.Enum.PaintApply)">
            <summary>
            将此渐变画笔应用到指定的画布上进行填充或描边操作
            </summary>
            <param name = "canvas">要应用渐变的画布</param>
            <param name = "apply">指定是将渐变应用于填充还是描边操作</param>
            <exception cref = "T:System.InvalidOperationException">
            当画布无效或渐变创建失败时抛出。
            </exception>
        </member>
        <member name="T:GameUI.Graphics.LinearGradientPaint">
            <summary>
            表示沿着由起点和终点定义的直线进行颜色过渡的线性渐变画笔
            </summary>
            <param name = "startPoint">线性渐变的起始点</param>
            <param name = "endPoint">线性渐变的结束点</param>
            <param name = "startColor">渐变起始点的颜色</param>
            <param name = "endColor">渐变结束点的颜色</param>
        </member>
        <member name="M:GameUI.Graphics.LinearGradientPaint.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            表示沿着由起点和终点定义的直线进行颜色过渡的线性渐变画笔
            </summary>
            <param name = "startPoint">线性渐变的起始点</param>
            <param name = "endPoint">线性渐变的结束点</param>
            <param name = "startColor">渐变起始点的颜色</param>
            <param name = "endColor">渐变结束点的颜色</param>
        </member>
        <member name="P:GameUI.Graphics.LinearGradientPaint.StartPoint">
            <summary>
            获取线性渐变的起始点
            </summary>
        </member>
        <member name="P:GameUI.Graphics.LinearGradientPaint.EndPoint">
            <summary>
            获取线性渐变的结束点
            </summary>
        </member>
        <member name="P:GameUI.Graphics.LinearGradientPaint.StartColor">
            <summary>
            获取渐变起始点的颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.LinearGradientPaint.EndColor">
            <summary>
            获取渐变结束点的颜色
            </summary>
        </member>
        <member name="M:GameUI.Graphics.LinearGradientPaint.CreateUnmanagedGradient">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Graphics.Paint">
            <summary>
            表示可用于填充形状的不同类型画笔的抽象基类
            </summary>
            <remarks>
            Paint用于Canvas.Fill和Canvas.Stroke方法，而<see cref = "N:GameUI.Brush"/>用于控件。
            </remarks>
        </member>
        <member name="P:GameUI.Graphics.Paint.IsTransparent">
            <summary>
            获取一个值，指示此画笔是否具有透明区域
            </summary>
            <remarks>
            派生类应重写此属性以正确指示其透明度。
            </remarks>
        </member>
        <member name="M:GameUI.Graphics.Paint.op_Implicit(System.Drawing.Color)~GameUI.Graphics.Paint">
            <summary>
            提供从<see cref = "T:System.Drawing.Color"/>到<see cref = "T:GameUI.Graphics.Paint"/>的隐式转换
            </summary>
            <param name = "color">要转换的颜色</param>
            <returns>使用指定颜色的<see cref = "T:GameUI.Graphics.SolidPaint"/>实例</returns>
        </member>
        <member name="T:GameUI.Graphics.PathF">
            <summary>
            表示一个2D图形路径，支持直线、曲线、圆弧等多种路径元素的构建和操作。
            该类提供了创建复杂几何形状、路径变换、边界计算等功能。
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF.K_RATIO">
            <summary>
            用于创建圆形和椭圆的贝塞尔曲线控制点的理想比例常数
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._arcAngles">
            <summary>
            存储圆弧的角度信息
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._arcClockwise">
            <summary>
            存储圆弧的绘制方向（顺时针或逆时针）
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._arcRadii">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._points">
            <summary>
            存储路径中的所有点坐标
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._lineLengths">
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._operations">
            <summary>
            存储路径操作序列（移动、直线、曲线等）
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._subPathCount">
            <summary>
            子路径的数量
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._subPathsClosed">
            <summary>
            记录每个子路径是否闭合
            </summary>
        </member>
        <member name="F:GameUI.Graphics.PathF._cachedBounds">
            <summary>
            缓存的边界矩形，用于提高性能
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.#ctor(System.Collections.Generic.List{System.Drawing.PointF},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Boolean},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{GameUI.Graphics.Enum.PathOperation},System.Int32)">
            <summary>
            使用指定的点、圆弧信息和操作序列创建PathF实例
            </summary>
            <param name = "points">路径点集合</param>
            <param name = "arcSizes">圆弧角度集合</param>
            <param name = "arcClockwise">圆弧方向集合</param>
            <param name = "operations">路径操作集合</param>
            <param name = "subPathCount">子路径数量</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.#ctor(GameUI.Graphics.PathF)">
            <summary>
            通过复制现有路径创建新的PathF实例
            </summary>
            <param name = "path">要复制的路径</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.#ctor(System.Drawing.PointF)">
            <summary>
            使用指定起始点创建PathF实例
            </summary>
            <param name = "point">起始点坐标</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.#ctor(System.Single,System.Single)">
            <summary>
            使用指定起始坐标创建PathF实例
            </summary>
            <param name = "x">起始点X坐标</param>
            <param name = "y">起始点Y坐标</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.#ctor">
            <summary>
            创建空的PathF实例
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.SubPathCount">
            <summary>
            获取子路径的数量
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.Closed">
            <summary>
            获取路径是否已闭合
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.FirstPoint">
            <summary>
            获取路径的第一个点
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.LastPoint">
            <summary>
            获取路径的最后一个点
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.Count">
            <summary>
            获取路径中点的总数
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.OperationCount">
            <summary>
            获取路径操作的总数
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.SegmentCountExcludingOpenAndClose">
            <summary>
            获取排除开始和结束操作后的路径段数量
            </summary>
            <remarks>
            该属性返回路径中除Move和Close操作之外的操作数量，主要用于计算实际的绘制段数。
            </remarks>
        </member>
        <member name="P:GameUI.Graphics.PathF.SegmentTypes">
            <summary>
            获取路径操作序列（移动、直线、曲线等）
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.Points">
            <summary>
            获取路径中的所有点坐标
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.LastPointIndex">
            <summary>
            获取路径中最后一个点的索引
            </summary>
        </member>
        <member name="P:GameUI.Graphics.PathF.Item(System.Int32)">
            <summary>
            获取或设置指定索引位置的点坐标
            </summary>
            <param name = "index">点的索引</param>
            <returns>指定索引位置的点坐标，如果索引无效则返回默认值</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetPoint(System.Int32,System.Single,System.Single)">
            <summary>
            设置路径中的点
            </summary>
            <param name = "index">点的索引</param>
            <param name = "x">点的X坐标</param>
            <param name = "y">点的Y坐标</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetPoint(System.Int32,System.Drawing.PointF)">
            <summary>
            设置路径中的点
            </summary>
            <param name = "index">点的索引</param>
            <param name = "point">点的坐标</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetSegmentType(System.Int32)">
            <summary>
            获取路径操作序列（移动、直线、曲线等）
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetArcAngle(System.Int32)">
            <summary>
            获取圆弧角度
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <returns>圆弧角度</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetArcAngle(System.Int32,System.Single)">
            <summary>
            设置圆弧角度
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <param name = "aValue">新的圆弧角度</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetArcRadius(System.Int32,System.Single)">
            <summary>
            设置圆弧半径
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <param name = "aValue">新的圆弧半径</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetArcRadius(System.Int32)">
            <summary>
            获取圆弧半径
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <returns>圆弧半径</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetLineLength(System.Int32)">
            <summary>
            获取线段长度
            </summary>
            <param name = "aIndex">线段索引</param>
            <returns>线段长度</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetLineLength(System.Int32,System.Single)">
            <summary>
            设置线段长度
            </summary>
            <param name = "aIndex">线段索引</param>
            <param name = "aValue">新的线段长度</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetArcClockwise(System.Int32)">
            <summary>
            获取圆弧方向
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <returns>圆弧方向（顺时针或逆时针）</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.SetArcClockwise(System.Int32,System.Boolean)">
            <summary>
            设置圆弧方向
            </summary>
            <param name = "aIndex">圆弧索引</param>
            <param name = "aValue">新的圆弧方向</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.MoveTo(System.Single,System.Single)">
            <summary>
            移动到指定坐标（开始新的子路径）
            </summary>
            <param name = "x">目标X坐标</param>
            <param name = "y">目标Y坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.MoveTo(System.Drawing.PointF)">
            <summary>
            移动到指定坐标（开始新的子路径）
            </summary>
            <param name = "point">目标点坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.Close">
            <summary>
            闭合当前子路径
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.Open">
            <summary>
            打开当前子路径
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.LineTo(System.Single,System.Single)">
            <summary>
            从当前位置绘制直线到指定坐标
            </summary>
            <param name = "x">目标X坐标</param>
            <param name = "y">目标Y坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.LineTo(System.Drawing.PointF)">
            <summary>
            从当前位置绘制直线到指定坐标
            </summary>
            <param name = "point">目标点坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.InsertLineTo(System.Drawing.PointF,System.Int32)">
            <summary>
            在指定位置插入直线到路径
            </summary>
            <param name = "point">要插入的点</param>
            <param name = "index">插入位置</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddEllipseArc(System.Drawing.PointF,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加椭圆弧到路径
            </summary>
            <param name = "center">椭圆中心点</param>
            <param name = "radiusX">X轴半径</param>
            <param name = "radiusY">Y轴半径</param>
            <param name = "rotation">椭圆旋转角度（度）</param>
            <param name = "startAngle">起始角度（度）</param>
            <param name = "endAngle">结束角度（度）</param>
            <param name = "clockwise">是否顺时针方向</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddCircleArc(System.Drawing.PointF,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加圆弧到路径
            </summary>
            <param name = "center">圆心</param>
            <param name = "radius">半径</param>
            <param name = "startAngle">起始角度（度）</param>
            <param name = "endAngle">结束角度（度）</param>
            <param name = "clockwise">是否顺时针方向</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.ArcTo(System.Drawing.PointF,System.Drawing.PointF,System.Single)">
            <summary>
            从当前位置绘制圆弧到指定位置
            </summary>
            <param name = "controlPoint1">第一个控制点</param>
            <param name = "controlPoint2">第二个控制点</param>
            <param name = "radius">圆弧半径</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.QuadTo(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制二次贝塞尔曲线
            </summary>
            <param name = "cx">控制点X坐标</param>
            <param name = "cy">控制点Y坐标</param>
            <param name = "x">终点X坐标</param>
            <param name = "y">终点Y坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.QuadTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            绘制二次贝塞尔曲线
            </summary>
            <param name = "controlPoint">控制点</param>
            <param name = "point">终点</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.InsertQuadTo(System.Drawing.PointF,System.Drawing.PointF,System.Int32)">
            <summary>
            在指定位置插入二次贝塞尔曲线到路径
            </summary>
            <param name = "controlPoint">控制点</param>
            <param name = "point">终点</param>
            <param name = "index">插入位置</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.CurveTo(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            绘制三次贝塞尔曲线
            </summary>
            <param name = "c1X">第一个控制点X坐标</param>
            <param name = "c1Y">第一个控制点Y坐标</param>
            <param name = "c2X">第二个控制点X坐标</param>
            <param name = "c2Y">第二个控制点Y坐标</param>
            <param name = "x">终点X坐标</param>
            <param name = "y">终点Y坐标</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.CurveTo(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            绘制三次贝塞尔曲线
            </summary>
            <param name = "controlPoint1">第一个控制点</param>
            <param name = "controlPoint2">第二个控制点</param>
            <param name = "point">终点</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.InsertCurveTo(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Int32)">
            <summary>
            在指定位置插入三次贝塞尔曲线到路径
            </summary>
            <param name = "controlPoint1">第一个控制点</param>
            <param name = "controlPoint2">第二个控制点</param>
            <param name = "point">终点</param>
            <param name = "index">插入位置</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddRectangle(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            添加矩形到路径
            </summary>
            <param name = "x">矩形左上角X坐标</param>
            <param name = "y">矩形左上角Y坐标</param>
            <param name = "w">矩形宽度</param>
            <param name = "h">矩形高度</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "x">矩形左上角X坐标</param>
            <param name = "y">矩形左上角Y坐标</param>
            <param name = "w">矩形宽度</param>
            <param name = "h">矩形高度</param>
            <param name = "cornerRadius">圆角半径</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddCircle(System.Drawing.PointF,System.Single)">
            <summary>
            添加圆形到路径
            </summary>
            <param name = "center">圆心</param>
            <param name = "radius">半径</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AddEllipse(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            添加椭圆到路径
            </summary>
            <param name = "center">椭圆中心点</param>
            <param name = "radiusX">X轴半径</param>
            <param name = "radiusY">Y轴半径</param>
            <returns>当前PathF实例，支持链式调用</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetSegmentPointIndex(System.Int32)">
            <summary>
            获取路径中点的索引
            </summary>
            <param name = "index">路径操作索引</param>
            <returns>点的索引</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetSegmentInfo(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            获取路径操作信息
            </summary>
            <param name = "segmentIndex">路径操作索引</param>
            <param name = "pointIndex">点索引</param>
            <param name = "arcAngleIndex">圆弧角度索引</param>
            <param name = "arcClockwiseIndex">圆弧方向索引</param>
            <returns>路径操作类型</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetSegmentForPoint(System.Int32)">
            <summary>
            获取路径中点的索引
            </summary>
            <param name = "pointIndex">点的索引</param>
            <returns>路径操作索引</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetPointsForSegment(System.Int32)">
            <summary>
            获取路径中点的集合
            </summary>
            <param name = "segmentIndex">路径操作索引</param>
            <returns>点的集合</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.RemoveAllSegmentsAfter(System.Int32)">
            <summary>
            移除路径中指定索引后的所有操作和点
            </summary>
            <param name = "segmentIndex">路径操作索引</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.RemoveSegment(System.Int32)">
            <summary>
            移除路径中指定索引的操作和点
            </summary>
            <param name = "segmentIndex">路径操作索引</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.Rotate(System.Single,System.Drawing.PointF)">
            <summary>
            旋转路径
            </summary>
            <param name = "angleAsDegrees">旋转角度（度）</param>
            <param name = "pivot">旋转中心点</param>
            <returns>旋转后的路径</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetRotatedPoint(System.Int32,System.Drawing.PointF,System.Single)">
            <summary>
            获取旋转后的点
            </summary>
            <param name = "pointIndex">点的索引</param>
            <param name = "pivotPoint">旋转中心点</param>
            <param name = "angle">旋转角度（度）</param>
            <returns>旋转后的点</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.Transform(System.Numerics.Matrix3x2)">
            <summary>
            使用变换矩阵对路径进行变换
            </summary>
            <param name = "transform">3x2变换矩阵</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.Separate">
            <summary>
            分离路径
            </summary>
            <returns>分离后的路径集合</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.Reverse">
            <summary>
            反转路径
            </summary>
            <returns>反转后的路径</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendEllipse(System.Drawing.RectangleF)">
            <summary>
            添加椭圆形状到路径
            </summary>
            <param name = "rect">椭圆的边界矩形</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendEllipse(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            添加椭圆形状到路径
            </summary>
            <param name = "x">椭圆边界框左上角X坐标</param>
            <param name = "y">椭圆边界框左上角Y坐标</param>
            <param name = "w">椭圆边界框宽度</param>
            <param name = "h">椭圆边界框高度</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendCircle(System.Drawing.PointF,System.Single)">
            <summary>
            添加圆形到路径
            </summary>
            <param name = "center">圆心坐标</param>
            <param name = "r">半径</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendCircle(System.Single,System.Single,System.Single)">
            <summary>
            添加圆形到路径
            </summary>
            <param name = "cx">圆心X坐标</param>
            <param name = "cy">圆心Y坐标</param>
            <param name = "r">半径</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRectangle(System.Drawing.RectangleF,System.Boolean)">
            <summary>
            添加矩形到路径
            </summary>
            <param name = "rect">矩形区域</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRectangle(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加矩形到路径
            </summary>
            <param name = "x">矩形左上角X坐标</param>
            <param name = "y">矩形左上角Y坐标</param>
            <param name = "w">矩形宽度</param>
            <param name = "h">矩形高度</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRoundedRectangle(System.Drawing.RectangleF,System.Single,System.Boolean)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "rect">矩形区域</param>
            <param name = "cornerRadius">圆角半径</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "x">矩形左上角X坐标</param>
            <param name = "y">矩形左上角Y坐标</param>
            <param name = "w">矩形宽度</param>
            <param name = "h">矩形高度</param>
            <param name = "cornerRadius">圆角半径</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRoundedRectangle(System.Drawing.RectangleF,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "rect">矩形区域</param>
            <param name = "topLeftCornerRadius">左上角圆角半径</param>
            <param name = "topRightCornerRadius">右上角圆角半径</param>
            <param name = "bottomLeftCornerRadius">左下角圆角半径</param>
            <param name = "bottomRightCornerRadius">右下角圆角半径</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRoundedRectangle(System.Drawing.RectangleF,System.Single,System.Single)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "rect">矩形区域</param>
            <param name = "xCornerRadius">X方向圆角半径</param>
            <param name = "yCornerRadius">Y方向圆角半径</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.AppendRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            添加圆角矩形到路径
            </summary>
            <param name = "x">矩形左上角X坐标</param>
            <param name = "y">矩形左上角Y坐标</param>
            <param name = "w">矩形宽度</param>
            <param name = "h">矩形高度</param>
            <param name = "topLeftCornerRadius">左上角圆角半径</param>
            <param name = "topRightCornerRadius">右上角圆角半径</param>
            <param name = "bottomLeftCornerRadius">左下角圆角半径</param>
            <param name = "bottomRightCornerRadius">右下角圆角半径</param>
            <param name = "includeLast">是否包含最后一条边</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.IsSubPathClosed(System.Int32)">
            <summary>
            检查指定子路径是否已闭合
            </summary>
            <param name = "subPathIndex">子路径的索引</param>
            <returns>如果指定子路径已闭合则返回true，否则返回false</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.Invalidate">
            <summary>
            使路径无效
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.Move(System.Single,System.Single)">
            <summary>
            移动路径
            </summary>
            <param name = "x">X方向移动量</param>
            <param name = "y">Y方向移动量</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.MovePoint(System.Int32,System.Single,System.Single)">
            <summary>
            移动路径中的点
            </summary>
            <param name = "index">点的索引</param>
            <param name = "dx">X方向移动量</param>
            <param name = "dy">Y方向移动量</param>
        </member>
        <member name="M:GameUI.Graphics.PathF.Equals(System.Object)">
            <summary>
            比较路径是否相等
            </summary>
            <param name = "obj">要比较的对象</param>
            <returns>是否相等</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetHashCode">
            <summary>
            获取路径的哈希码
            </summary>
            <returns>哈希码</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.Equals(System.Object,System.Single)">
            <summary>
            比较路径是否相等
            </summary>
            <param name = "obj">要比较的对象</param>
            <param name = "epsilon">比较精度</param>
            <returns>是否相等</returns>
        </member>
        <member name="P:GameUI.Graphics.PathF.Bounds">
            <summary>
            获取路径的边界矩形
            </summary>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetBoundsByFlattening(System.Single)">
            <summary>
            获取路径的边界矩形
            </summary>
            <param name = "flatness">扁平化精度，值越小越精确</param>
            <returns>边界矩形</returns>
        </member>
        <member name="M:GameUI.Graphics.PathF.GetFlattenedPath(System.Single,System.Boolean)">
            <summary>
            将路径扁平化为直线段序列
            </summary>
            <param name = "flatness">扁平化精度，值越小越精确</param>
            <param name = "includeSubPaths">是否包含所有子路径</param>
            <returns>扁平化后的路径</returns>
        </member>
        <member name="T:GameUI.Graphics.RadialGradientPaint">
            <summary>
            表示从中心点向外扩散进行颜色过渡的径向渐变画笔
            </summary>
            <param name = "centerPoint">径向渐变的中心点</param>
            <param name = "startRadius">渐变的起始半径（内半径）</param>
            <param name = "endRadius">渐变的结束半径（外半径）</param>
            <param name = "startColor">渐变中心（起始半径）处的颜色</param>
            <param name = "endColor">渐变边缘（结束半径）处的颜色</param>
        </member>
        <member name="M:GameUI.Graphics.RadialGradientPaint.#ctor(System.Drawing.PointF,System.Single,System.Single,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            表示从中心点向外扩散进行颜色过渡的径向渐变画笔
            </summary>
            <param name = "centerPoint">径向渐变的中心点</param>
            <param name = "startRadius">渐变的起始半径（内半径）</param>
            <param name = "endRadius">渐变的结束半径（外半径）</param>
            <param name = "startColor">渐变中心（起始半径）处的颜色</param>
            <param name = "endColor">渐变边缘（结束半径）处的颜色</param>
        </member>
        <member name="P:GameUI.Graphics.RadialGradientPaint.CenterPoint">
            <summary>
            获取径向渐变的中心点
            </summary>
        </member>
        <member name="P:GameUI.Graphics.RadialGradientPaint.StartRadius">
            <summary>
            获取渐变的起始半径（内半径）
            </summary>
        </member>
        <member name="P:GameUI.Graphics.RadialGradientPaint.EndRadius">
            <summary>
            获取渐变的结束半径（外半径）
            </summary>
        </member>
        <member name="P:GameUI.Graphics.RadialGradientPaint.StartColor">
            <summary>
            获取渐变中心（起始半径）处的颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.RadialGradientPaint.EndColor">
            <summary>
            获取渐变边缘（结束半径）处的颜色
            </summary>
        </member>
        <member name="M:GameUI.Graphics.RadialGradientPaint.CreateUnmanagedGradient">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Graphics.SolidPaint">
            <summary>
            表示使用纯色填充形状的画笔
            </summary>
            <remarks>
            使用指定颜色初始化<see cref = "T:GameUI.Graphics.SolidPaint"/>类的新实例。
            </remarks>
            <param name = "color">用于填充形状的颜色</param>
        </member>
        <member name="M:GameUI.Graphics.SolidPaint.#ctor(System.Drawing.Color)">
            <summary>
            表示使用纯色填充形状的画笔
            </summary>
            <remarks>
            使用指定颜色初始化<see cref = "T:GameUI.Graphics.SolidPaint"/>类的新实例。
            </remarks>
            <param name = "color">用于填充形状的颜色</param>
        </member>
        <member name="P:GameUI.Graphics.SolidPaint.Color">
            <summary>
            获取或设置用于填充形状的颜色
            </summary>
        </member>
        <member name="P:GameUI.Graphics.SolidPaint.IsTransparent">
            <summary>
            获取一个值，指示此画笔是否具有透明区域
            </summary>
            <remarks>
            当纯色画笔颜色的alpha值小于255时，被认为是透明的。
            </remarks>
        </member>
        <member name="M:GameUI.Graphics.SolidPaint.ToString">
            <summary>
            返回此纯色画笔的字符串表示形式
            </summary>
            <returns>包含类型名称和颜色信息的字符串</returns>
        </member>
        <member name="M:GameUI.Graphics.SolidPaint.op_Implicit(System.Drawing.Color)~GameUI.Graphics.SolidPaint">
            <summary>
            将<see cref = "T:System.Drawing.Color"/>隐式转换为<see cref = "T:GameUI.Graphics.SolidPaint"/>
            </summary>
            <param name = "color">要转换的颜色</param>
            <returns>使用指定颜色的新<see cref = "T:GameUI.Graphics.SolidPaint"/>实例</returns>
        </member>
        <member name="T:GameUI.Interface.INode">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Interface.INode.DataContext">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Interface.INode.Children">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Interface.INode.AddChild(GameUI.Interface.INodeChild)">
            <summary>
            
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INode.RemoveChild(GameUI.Interface.INodeChild)">
            <summary>
            
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INode.RemoveChild(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INode.IsAncestorOf(GameUI.Interface.INodeChild)">
            <summary>
            
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INode.FindChild(System.Func{GameUI.Interface.INodeChild,System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:GameUI.Interface.INodeChild">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.Interface.INodeChild.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Interface.INodeChild.AddToParent(GameUI.Interface.INode)">
            <summary>
            
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INodeChild.AddToParent(GameUI.Interface.INode,System.Int32)">
            <summary>
            
            </summary>
            <param name="parent"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GameUI.Interface.INodeChild.RemoveFromParent">
            <summary>
            Only remove from parent, not from collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:GameUI.Standard.DoubleUtilities">
            <summary>
            DoubleUtil uses fixed eps to provide fuzzy comparison functionality for doubles.
            Note that FP noise is a big problem and using any of these compare 
            methods is not a complete solution, but rather the way to reduce 
            the probability of repeating unnecessary work.
            </summary>
        </member>
        <member name="F:GameUI.Standard.DoubleUtilities.Epsilon">
            <summary>
            Epsilon - more or less random, more or less small number.
            </summary>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.AreClose(System.Double,System.Double)">
            <summary>
            AreClose returns whether or not two doubles are "close".  That is, whether or 
            not they are within epsilon of each other.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this 
            returns false. 
            </summary>
            <param name = "value1">The first double to compare.</param>
            <param name = "value2">The second double to compare.</param>
            <returns>The result of the AreClose comparision.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.LessThan(System.Double,System.Double)">
            <summary>
            LessThan returns whether or not the first double is less than the second double.
            That is, whether or not the first is strictly less than *and* not within epsilon of
            the other number.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this 
            returns false.
            </summary>
            <param name = "value1">The first double to compare.</param>
            <param name = "value2">The second double to compare.</param>
            <returns>The result of the LessThan comparision.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.GreaterThan(System.Double,System.Double)">
            <summary>
            GreaterThan returns whether or not the first double is greater than the second double.
            That is, whether or not the first is strictly greater than *and* not within epsilon of
            the other number.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this 
            returns false.
            </summary>
            <param name = "value1">The first double to compare.</param>
            <param name = "value2">The second double to compare.</param>
            <returns>The result of the GreaterThan comparision.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.LessThanOrClose(System.Double,System.Double)">
            <summary>
            LessThanOrClose returns whether or not the first double is less than or close to
            the second double.  That is, whether or not the first is strictly less than or within
            epsilon of the other number.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this 
            returns false.
            </summary>
            <param name = "value1">The first double to compare.</param>
            <param name = "value2">The second double to compare.</param>
            <returns>The result of the LessThanOrClose comparision.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.GreaterThanOrClose(System.Double,System.Double)">
            <summary>
            GreaterThanOrClose returns whether or not the first double is greater than or close to
            the second double.  That is, whether or not the first is strictly greater than or within
            epsilon of the other number.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this 
            returns false.
            </summary>
            <param name = "value1">The first double to compare.</param>
            <param name = "value2">The second double to compare.</param>
            <returns>The result of the GreaterThanOrClose comparision.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.IsFinite(System.Double)">
            <summary>
            Test to see if a double is a finite number (is not NaN or Infinity).
            </summary>
            <param name = 'value'>The value to test.</param>
            <returns>Whether or not the value is a finite number.</returns>
        </member>
        <member name="M:GameUI.Standard.DoubleUtilities.IsValidSize(System.Double)">
            <summary>
            Test to see if a double a valid size value (is finite and > 0).
            </summary>
            <param name = 'value'>The value to test.</param>
            <returns>Whether or not the value is a valid size value.</returns>
        </member>
        <member name="T:GameUI.Struct.UIPosition">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Struct.UIPosition.#ctor(System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGameInput">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGameInput.Modifiers">
            <summary>
            The virtual key modifiers, such as Shift, Ctrl, or Alt, that were pressed when the event occurred.
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGameInput.PointerButtons">
            <summary>
            The pointer buttons that were pressed when the event occurred. For mouse events, this indicates which mouse buttons were pressed. For finger events, differentiate between fingers by using the touching ID.
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGameKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGameKey.Key">
            <summary>
            The virtual key that triggered the event.
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGameKeyDown">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGameKeyDown.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGameKeyDown.IsRepeat">
            <summary>
            Indicates whether the event was triggered by a key long press.
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGameKeyDown.#ctor(GameCore.Platform.SDL.VirtualKey,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons,System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGameKeyUp">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGameKeyUp.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGameKeyUp.#ctor(GameCore.Platform.SDL.VirtualKey,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGamePointerButton">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGamePointerButton.EventPointerButton">
            <summary>
            The pointer button that triggered the event.
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGamePointerButton.PointerPosition">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGamePointerButtonDown">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonDown.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonDown.#ctor(GameCore.Platform.SDL.PointerButtons,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGamePointerButtonUp">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonUp.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonUp.#ctor(GameCore.Platform.SDL.PointerButtons,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGamePointerButtonMove">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonMove.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerButtonMove.#ctor(GameCore.Platform.SDL.PointerButtons,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.TriggerEvent.EventGamePointerWheelChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerWheelChanged.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.TriggerEvent.EventGamePointerWheelChanged.Amount">
            <summary>
            The changed amount of the wheel.
            </summary>
        </member>
        <member name="M:GameUI.TriggerEvent.EventGamePointerWheelChanged.#ctor(System.Int32,GameCore.Platform.Urho.VirtualKeyModifiers,GameCore.Platform.SDL.PointerButtons)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.CameraSystem.Camera">
            <summary>
            表示游戏中的摄像机对象，支持跟随目标、切换视角、设置变换、震动等功能。
            </summary>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Camera.Link">
            <summary>
            获取摄像机的数据链接。
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Camera.Cache">
            <summary>
            获取摄像机的数据缓存。
            </summary>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.Switch(GameData.IGameLink{GameUI.CameraSystem.Data.GameDataCamera},System.TimeSpan)">
            <summary>
            切换摄像机到指定数据链接。
            </summary>
            <param name = "link">目标摄像机数据链接。</param>
            <param name = "duration">切换动画时长。</param>
        </member>
        <member name="F:GameUI.CameraSystem.Camera.followTarget">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Camera.FollowTarget">
            <summary>
            获取或设置摄像机的跟随目标。
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Camera.Transform">
            <summary>
            获取摄像机的变换信息（位置、旋转、焦距）。
            </summary>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.SetPosition(System.Numerics.Vector3,System.TimeSpan)">
            <summary>
            设置摄像机的位置。
            </summary>
            <param name = "position">目标位置。</param>
            <param name = "transitionTime">过渡动画时长。</param>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.SetRotation(GameCore.CameraSystem.Struct.CameraRotation,System.TimeSpan)">
            <summary>
            设置摄像机的旋转。
            </summary>
            <param name = "rotation">目标旋转。</param>
            <param name = "transitionTime">过渡动画时长。</param>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.SetFocalLength(System.Single,System.TimeSpan)">
            <summary>
            设置摄像机的焦距。
            </summary>
            <param name = "focalLength">目标焦距。</param>
            <param name = "transitionTime">过渡动画时长。</param>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.SetTransform(GameUI.CameraSystem.Struct.CameraTransform,System.TimeSpan)">
            <summary>
            设置摄像机的完整变换。
            </summary>
            <param name = "transform">目标变换。</param>
            <param name = "transitionTime">过渡动画时长。</param>
        </member>
        <member name="P:GameUI.CameraSystem.Camera.Lock">
            <summary>
            获取或设置摄像机锁定状态。
            </summary>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.Shake(System.Single,System.TimeSpan,System.Single,GameUI.CameraSystem.Enum.CameraShakeDirection)">
            <summary>
            使摄像机产生震动效果。
            </summary>
            <param name = "intensity">震动强度。</param>
            <param name = "duration">震动时长。</param>
            <param name = "frequency">震动频率。</param>
            <param name = "direction">震动方向。</param>
        </member>
        <member name="M:GameUI.CameraSystem.Camera.RotateAround(GameCore.SceneSystem.ScenePoint,GameCore.BaseType.Angle,System.TimeSpan)">
            <summary>
            使摄像机围绕指定点旋转。
            </summary>
            <param name = "point">旋转中心点。</param>
            <param name = "rate">旋转速率。</param>
            <param name = "duration">旋转时长。</param>
        </member>
        <member name="T:GameUI.CameraSystem.Struct.CameraTransform">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Struct.CameraTransform.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Struct.CameraTransform.Rotation">
            <summary>
            Gets the rotation of the camera in 3D space. Euler angles in degrees.
            </summary>
        </member>
        <member name="P:GameUI.CameraSystem.Struct.CameraTransform.FocalLength">
            <summary>
            
            </summary>
        </member>
        <member name="T:GameUI.Debug.DebugDraw">
            <summary>
            Provides utility methods for drawing debug shapes and text in the game scene.
            This class allows developers to visualize geometric primitives such as lines, circles, points, sectors, parallelograms, and text for debugging purposes.
            </summary>
            <summary>
            
            </summary>
        </member>
        <member name="F:GameUI.Debug.DebugDraw.viewActorId">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref = "T:GameUI.Debug.DebugDraw"/> class with the specified view actor ID.
            </summary>
            <param name = "viewActorId">The identifier for the debug view actor.</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.Create">
            <summary>
            Creates a new <see cref = "T:GameUI.Debug.DebugDraw"/> instance if the debug graph can be created successfully.
            </summary>
            <returns>A <see cref = "T:GameUI.Debug.DebugDraw"/> instance if successful; otherwise, <c>null</c>.</returns>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.Clear">
            <summary>
            Clears all debug drawings from the current debug graph.
            </summary>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawLine(System.Numerics.Vector3,System.Numerics.Vector3,System.Drawing.Color)">
            <summary>
            Draws a line between two points in 3D space.
            </summary>
            <param name = "origin">The starting point of the line.</param>
            <param name = "end">The ending point of the line.</param>
            <param name = "color">The color of the line.</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawCircle(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Drawing.Color,System.Boolean)">
            <summary>
            Draws a circle in 3D space.
            </summary>
            <param name = "center">The center of the circle.</param>
            <param name = "eulerRotation">The rotation of the circle in Euler angles (degrees).</param>
            <param name = "radius">The radius of the circle.</param>
            <param name = "color">The color of the circle.</param>
            <param name = "fill">Whether to fill the circle (true) or draw only the outline (false).</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawPoint(System.Numerics.Vector3,System.Drawing.Color)">
            <summary>
            Draws a point in 3D space.
            </summary>
            <param name = "point">The position of the point.</param>
            <param name = "color">The color of the point.</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawText(System.Numerics.Vector3,System.String,System.Drawing.Color,System.Boolean)">
            <summary>
            Draws text at a specified position in 3D space.
            </summary>
            <param name = "position">The position where the text will be drawn.</param>
            <param name = "text">The text to display.</param>
            <param name = "color">The color of the text.</param>
            <param name = "onTopOfEverything">Whether to render the text on top of all other elements.</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawSector(System.Numerics.Vector3,System.Numerics.Vector3,System.Single,System.Single,System.Drawing.Color,System.Boolean)">
            <summary>
            Draws a sector (pie slice) in 3D space.
            </summary>
            <param name = "center">The center of the sector.</param>
            <param name = "eulerRotation">The rotation of the sector in Euler angles (degrees).</param>
            <param name = "radius">The radius of the sector.</param>
            <param name = "angle">The angle of the sector in degrees.</param>
            <param name = "color">The color of the sector.</param>
            <param name = "fill">Whether to fill the sector (true) or draw only the outline (false).</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawParallelogram(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Drawing.Color,System.Boolean)">
            <summary>
            Draws a parallelogram in 3D space, defined by an origin and two side vectors.
            </summary>
            <param name = "origin">The origin (one corner) of the parallelogram.</param>
            <param name = "sideVectorA">The first side vector from the origin.</param>
            <param name = "sideVectorB">The second side vector from the origin.</param>
            <param name = "color">The color of the parallelogram.</param>
            <param name = "fill">Whether to fill the parallelogram (true) or draw only the outline (false).</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DrawRectangle(System.Numerics.Vector3,System.Single,System.Single,System.Numerics.Vector3,System.Drawing.Color,System.Boolean)">
            <summary>
            Draws a rectangle in 3D space, defined by its center, width, height, and rotation (XYZ order).
            </summary>
            <param name = "center">The center of the rectangle.</param>
            <param name = "width">The width of the rectangle.</param>
            <param name = "height">The height of the rectangle.</param>
            <param name = "rotation">The rotation of the rectangle in Euler angles (degrees, XYZ order).</param>
            <param name = "color">The color of the rectangle.</param>
            <param name = "fill">Whether to fill the rectangle (true) or draw only the outline (false).</param>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DisposeManaged">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GameUI.Debug.DebugDraw.DisposeUnmanaged(System.Boolean)">
            <summary>
            
            </summary>
            <param name="finalizing"></param>
            <returns></returns>
        </member>
    </members>
</doc>
